<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><script defer language=javascript type=text/javascript src=/js/bundle.min.14549c76bbc96f0af1574b0259efd70e52908cd36fb4d14ed3d290a1b6479eae.js></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=/images/p2.png><title itemprop=name>空树之空</title><meta property="og:title" content="空树之空"><meta name=twitter:title content="空树之空"><meta itemprop=name content="空树之空"><meta name=application-name content="空树之空"><meta property="og:site_name" content="空树之空"><meta name=description content="《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes、DevOps和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。"><meta itemprop=description content="《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes、DevOps和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。"><meta property="og:description" content="《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes、DevOps和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。"><meta name=twitter:description content="《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes、DevOps和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。"><base href=https://yezihack.github.io/><link rel=canonical href=https://yezihack.github.io/ itemprop=url><meta name=url content="https://yezihack.github.io/"><meta name=twitter:url content="https://yezihack.github.io/"><meta property="og:url" content="https://yezihack.github.io/"><meta property="og:updated_time" content="30001-30-06T152:04:24+0800"><link rel=sitemap type=application/xml title=Sitemap href=https://yezihack.github.io/sitemap.xml><link href=https://yezihack.github.io/index.xml rel=alternate type=application/rss+xml title=空树之空><meta name=robots content="index,follow"><meta name=googlebot content="index,follow"><meta name=twitter:site content><meta name=twitter:creator content><meta property="fb:admins" content><meta name=apple-mobile-web-app-title content="空树之空"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta property="og:type" content="website"><meta name=author content><script defer type=application/ld+json>{"@context":"http://schema.org","@type":"Article","headline":"空树之空","author":{"@type":"Person","name":""},"datePublished":"2024-01-30","description":"","wordCount":"0","mainEntityOfPage":"True","dateModified":"2024-01-30","image":{"@type":"imageObject","url":""},"publisher":{"@type":"Organization","name":"空树之空","logo":{"@type":"imageObject","url":"\/images\/p2.png"}}}</script><meta name=generator content="Hugo 0.114.0"><link type=text/css rel=stylesheet href=/css/bundle.min.aa949ea27ee9836d60d6ea4c073fd0885f51948c7eea0247da6b1aff4bc25c44.css><style>body{--sidebar-bg-color:#202020;--sidebar-img-border-color:#515151;--sidebar-p-color:#909090;--sidebar-h1-color:#FFF;--sidebar-a-color:#FFF;--sidebar-socials-color:#FFF;--text-color:#222;--bkg-color:#FAF9F6;--post-title-color:#303030;--list-color:#5a5a5a;--link-color:#268bd2;--date-color:#515151;--table-border-color:#E5E5E5;--table-stripe-color:#F9F9F9;--code-color:#bf616a;--code-background-color:#E5E5E5;--moon-sun-color:#FFF;--moon-sun-background-color:#515151}body.dark-theme{--text-color:#eee;--bkg-color:#121212;--post-title-color:#DBE2E9;--list-color:#9d9d9d;--link-color:#268bd2;--date-color:#9a9a9a;--table-border-color:#515151;--table-stripe-color:#202020;--code-color:#ff7f7f;--code-background-color:#393D47}body{background-color:var(--bkg-color)}</style></head><body class=dark-theme><div class=wrapper><aside class=sidebar><div class="container sidebar-sticky"><div class=light-dark align=right><button class=btn-light-dark title="Toggle light/dark mode"><svg class="moon" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16"><path fill="currentcolor" d="M6 .278a.768.768.0 01.08.858 7.208 7.208.0 00-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527.0 1.04-.055 1.533-.16a.787.787.0 01.81.316.733.733.0 01-.031.893A8.349 8.349.0 018.344 16C3.734 16 0 12.286.0 7.71.0 4.266 2.114 1.312 5.124.06A.752.752.0 016 .278z"/></svg><svg class="sun" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16"><path fill="currentcolor" d="M8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 0zm0 13a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 13zm8-5a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2a.5.5.0 01.5.5zM3 8a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2A.5.5.0 013 8zm10.657-5.657a.5.5.0 010 .707l-1.414 1.415a.5.5.0 11-.707-.708l1.414-1.414a.5.5.0 01.707.0zm-9.193 9.193a.5.5.0 010 .707L3.05 13.657a.5.5.0 01-.707-.707l1.414-1.414a.5.5.0 01.707.0zm9.193 2.121a.5.5.0 01-.707.0l-1.414-1.414a.5.5.0 01.707-.707l1.414 1.414a.5.5.0 010 .707zM4.464 4.465a.5.5.0 01-.707.0L2.343 3.05a.5.5.0 11.707-.707l1.414 1.414a.5.5.0 010 .708z"/></svg></button></div><div class=sidebar-about><h1 class=brand><a href=https://yezihack.github.io/><img src=/images/logo_transparent.png alt="brand image"></a>
<a href=https://yezihack.github.io/><h1>空树之空</h1></a></h1><p class=lead>《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes、DevOps和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。</p></div><nav><ul class=sidebar-nav><li class=heading><a href=/about/>About</a></li><li class=heading><a href=/posts/>Posts</a></li><li class=sub-heading>Recent</li><li class=bullet><a href=https://yezihack.github.io/posts/linux-ssh-agent/>Linux ssh-agent 极简教程</a></li><li class=bullet><a href=https://yezihack.github.io/posts/linux-ccze/>Linux Ccze 彩色化日志文件输出的工具</a></li><li class=bullet><a href=https://yezihack.github.io/posts/wsl-install/>Windows 子系统 Linux 系统之 WSL2 安装</a></li><li class=bullet><a href=https://yezihack.github.io/posts/firewalld/>Linux Firewalld 极简教程</a></li><li class=bullet><a href=https://yezihack.github.io/posts/chronyd/>Linux Chronyd 极简教程</a></li><li class=heading><a href=/tags/>Tags</a></li></ul></nav><a target=_blank class=social title="RSS Feed" href=https://yezihack.github.io//posts/index.xml><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1.2em" viewBox="0 0 1280 1280"><g transform="translate(0.000000,1280.000000) scale(0.100000,-0.100000)" fill="currentcolor"><path d="M2295 11929c-284-12-642-45-707-65-17-5-18-63-18-1039 0-569 4-1036 8-1039 5-3 74 6 153 19 510 86 1168 95 1789 25 1348-153 2602-677 3670-1531 385-308 820-744 1126-1129 842-1060 1362-2313 1514-3650 70-621 61-1279-25-1789-13-79-22-148-19-153 3-4 471-8 1039-8h1035l5 23c51 225 85 942 67 1419-23 605-77 1044-198 1617-294 14e2-927 2734-1823 3846-1043 1295-2364 2259-3909 2854-1158 447-2451 656-3707 6e2z"/><path d="M2255 7845c-269-25-620-81-667-106-17-9-18-55-18-899 0-706 3-890 13-890 6 0 66 18 132 41 130 44 288 79 467 105 154 21 577 30 749 15 1207-107 2267-823 2814-1902 166-327 268-637 330-1001 38-227 48-384 42-662-8-348-44-590-126-831-23-66-41-126-41-132 0-10 184-13 890-13 844 0 890 1 899 18 27 50 88 452 110 725 14 162 14 624 1 782-59 703-233 1323-545 1945-481 956-1313 1788-2270 2268-620 310-1239 483-1940 542-165 14-669 10-840-5z"/><path d="M2519 3815c-391-66-725-336-868-703-79-201-96-462-45-677 83-344 338-641 666-774 116-47 205-69 330-80 412-39 811 153 1040 5e2 193 292 240 648 128 981-135 403-492 699-914 757-1e2 14-241 12-337-4z"/></g></svg></a><p class=footnote><br>&copy; 2024 百里江山. All rights reserved.</p></div></aside><main class="content container"><div class=posts><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/linux-ssh-agent/>Linux ssh-agent 极简教程</a></h1><time datetime=2024-01-30T18:52:04+0800 class=post-date>January 30, 2024</time><ul class=tags><li class=tag-linux><a href=https://yezihack.github.io/tags/linux>linux</a></li><li class=tag-ssh><a href=https://yezihack.github.io/tags/ssh>ssh</a></li><li class=tag-极简教程><a href=https://yezihack.github.io/tags/%E6%9E%81%E7%AE%80%E6%95%99%E7%A8%8B>极简教程</a></li></ul></div>.1. ssh-agent 简介 .2. 原理图 .3. 生成密钥对 .4. 开启 ssh-agent .5. ssh-add 管理密钥 .5.1. 添加 .5.2. 查看 .5.3. 删除 .6. 复制公钥 .7. ssh 免密连接 .8. 终结 ssh-agent .1. ssh-agent 简介 ssh-agent 是一个用于管理 SSH 密钥的认证代理，它可以在一段时间内缓存您的私钥，使得在此期间内无需重复输入密码即可进行 SSH 连接。下面是关于 ssh-agent 的优缺点：
优点：
方便性：ssh-agent 可以让用户在一定时间内轻松地管理和使用他们的 SSH 密钥，而无需反复输入密码。 安全性：通过 ssh-agent，用户可以将私钥保存在内存中而不是硬盘上，从而减少私钥被恶意获取的风险。 自动化：对于脚本或其他自动化操作，ssh-agent 可以让您无需人工干预即可进行安全的 SSH 连接。 缺点：
安全性考量：尽管 ssh-agent 提高了私钥的安全性，但一旦攻击者获得了对系统的完全控制权限，仍然可能访问到内存中的私钥。 生命周期管理：ssh-agent 中缓存的密钥在一定时间内保持有效，这可能会导致一些安全隐患，特别是在共享计算机上使用时。
总的来说，ssh-agent 为 SSH 密钥的管理提供了便利性和安全性，但在使用时仍需用户对其安全性有清晰的认识，并设置合适的安全策略以确保数据的安全。
.2. 原理图 .3. 生成密钥对 随机密码：https://suijimimashengcheng.bmcx.com/ mkdir /opt/.ssh # 生成带密钥的密钥对 ssh-keygen -f &lt;文件名称> -t rsa -P &lt;3种类型16位以上的密码> # 例1 显式输入密码 ssh-keygen -f box -t rsa -P "16位以上的密码" # 例2 隐式输入密码（推荐） ssh-keygen -f box -t rsa 生成两个文件<div class=read-more-link><a href=/posts/linux-ssh-agent/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/linux-ccze/>Linux Ccze 彩色化日志文件输出的工具</a></h1><time datetime=2024-01-21T17:50:55+0800 class=post-date>January 21, 2024</time><ul class=tags><li class=tag-linux><a href=https://yezihack.github.io/tags/linux>linux</a></li><li class=tag-tools><a href=https://yezihack.github.io/tags/tools>tools</a></li></ul></div>.1. 什么是 ccze ccze 是 Linux 一个用于彩色化日志文件输出的工具。它可以将文本文件中的日志内容进行颜色标记，以提高可读性。
.2. 安装 # 对于Debian/Ubuntu系统 sudo apt-get install ccze # 对于CentOS/RHEL系统 sudo yum install ccze .3. 使用 -A 选项用于启用ANSI颜色代码 cat nginx.log |ccze -A cat nginx.log |ccze -A | more journalctl -xeu docker|ccze -A|more docker logs xxx |ccze 导出 HTML
cat /var/log/messages |ccze -h > ~/messages.html .4. 参考 https://www.cnblogs.com/flashfish/p/11230141.html https://lintut.com/colorize-log-files-on-linux-using-ccze-tool/</article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/wsl-install/>Windows 子系统 Linux 系统之 WSL2 安装</a></h1><time datetime=2024-01-21T10:38:00+0800 class=post-date>January 21, 2024</time><ul class=tags><li class=tag-linux><a href=https://yezihack.github.io/tags/linux>linux</a></li><li class=tag-win><a href=https://yezihack.github.io/tags/win>win</a></li><li class=tag-ubuntu><a href=https://yezihack.github.io/tags/ubuntu>ubuntu</a></li></ul></div>.1. 为什么安装 WSL .2. 安装 WSL .3. 配置优化 .4. 安装基础软件 .5. 参考 .1. 为什么安装 WSL 如果你的操作系统是 windows 系列则有必须了解一下 WSL，对于开发者来说必备的工具。
Windows Subsystem for Linux（简称WSL）是微软开发的一种允许在Windows操作系统上运行Linux二进制可执行文件（ELF格式）的兼容层。WSL将Linux内核的子系统嵌入到Windows中，使得用户可以在Windows环境中使用Linux工具、命令和应用程序。
WSL的主要特点包括：
全面兼容性：WSL提供了高度兼容的Linux系统调用接口，可以运行大多数基于Linux的工具和应用程序，无需进行修改或重新编译。
轻量化和快速启动：WSL只需要很小的资源开销，并且可以在几秒钟内启动。这使得在Windows系统上使用Linux工具和应用程序变得更加便捷。
文件系统互通：WSL可以访问Windows文件系统，并且Windows和Linux之间的文件共享也变得非常容易。用户可以在Windows和Linux之间方便地共享文件和目录。
命令行工具：WSL支持使用各种命令行工具，如Bash、Zsh、Fish等，提供了丰富的Shell环境和命令行工具集。
自定义配置和扩展：WSL允许用户自定义Linux发行版，并且可以通过安装各种软件包来扩展功能。用户可以选择安装适合自己需求的发行版，并根据需要进行自定义配置。
使用WSL可以带来许多好处，例如在Windows环境中开发和运行Linux软件、使用Linux命令行工具和脚本、学习和测试Linux等。WSL目前有两个主要版本，即WSL 1和WSL 2，用户可以根据自己的需求选择适合自己的版本。
总之，WSL为Windows用户提供了与Linux系统无缝集成的能力，使得在Windows环境下使用Linux变得更加方便和灵活。
.2. 安装 WSL # 打开PowerShell作为管理员，执行以下命令，以启用WSL特性 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart # 然后，执行以下命令以启用虚拟机平台： dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 更新 WSL
https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi 将WSL 2设置为默认版本：
wsl --set-default-version 2 安装最新的 Ubuntu 最新发行版本：
wsl --install # 一会需要设置帐号和密码 将安装的 ubuntu 设置默认系统<div class=read-more-link><a href=/posts/wsl-install/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/firewalld/>Linux Firewalld 极简教程</a></h1><time datetime=2023-12-29T15:44:25+0800 class=post-date>December 29, 2023</time><ul class=tags><li class=tag-linux><a href=https://yezihack.github.io/tags/linux>linux</a></li><li class=tag-firewalld><a href=https://yezihack.github.io/tags/firewalld>firewalld</a></li><li class=tag-极简教程><a href=https://yezihack.github.io/tags/%E6%9E%81%E7%AE%80%E6%95%99%E7%A8%8B>极简教程</a></li></ul></div>1. 什么是 Firewalld Firewalld 是一个在 Linux 系统上提供动态防火墙管理的工具。它是一个用户和管理员友好的前端，用于配置和管理 iptables 规则，并提供了一种简化的方式来管理网络连接和保护系统免受未经授权的访问。
Firewalld 的主要特点包括：
基于区域的防火墙：Firewalld 将网络接口划分为不同的区域，例如公共区域、内部区域和信任区域。每个区域都有其自己的安全策略和规则集。 动态更新规则：Firewalld 允许实时添加、删除和修改防火墙规则，而无需重启防火墙服务或中断网络连接。 服务和应用程序级别的访问控制：Firewalld 允许根据服务或应用程序的名称来控制网络访问权限，而不仅仅是基于端口号。 高级网络管理功能：Firewalld 支持网络地址转换（NAT）、端口转发、IPSec 和 IPv6 等高级网络功能。 兼容性和扩展性：Firewalld 可以与其他网络管理工具和服务集成，如 NetworkManager 和 SELinux。 使用 Firewalld，管理员可以轻松地配置和管理系统的防火墙设置，保护系统免受恶意网络活动和未经授权的访问。它提供了一种灵活且强大的方式来管理网络连接，并根据实际需求进行定制配置。
需要注意的是，Firewalld 本身并不是防火墙，而是一个防火墙管理工具。
2. 工作原理 Firewalld 的工作原理可以简要概括如下：
区域和服务定义：Firewalld 使用预定义的区域和服务来管理网络连接和访问控制。区域定义了特定接口的安全策略，而服务定义了允许的网络服务和端口。
运行时状态：Firewalld 在运行时维护一个状态，以跟踪网络连接和防火墙规则的变化。它监视网络接口上的数据包流量，并根据规则进行决策。
防火墙规则集：Firewalld 根据配置文件中定义的防火墙规则集来处理传入和传出的数据包。规则可以基于源 IP、目标 IP、源端口、目标端口等条件进行匹配，并决定是允许还是拒绝数据包。
动态更新：Firewalld 允许在运行时动态地添加、删除和修改防火墙规则，而无需重启防火墙服务或中断网络连接。这使得管理员可以实时地对网络连接进行调整和控制。
网络地址转换（NAT）和端口转发：Firewalld 支持配置网络地址转换（NAT）和端口转发规则，以便将数据包从一个网络接口转发到另一个接口或端口。
D-Bus 接口：Firewalld 提供了一个 D-Bus 接口，使其他应用程序和工具可以与其交互并管理防火墙设置。
Firewalld 是通过定义防火墙规则最终交由内核的 netfilter 进行包过滤实现防火墙功能。
3. 架构图 以下是官方给出的架构图，https://firewalld.org/documentation/architecture.html
Firewalld 是一个复杂的系统，包含了多个组件和模块来实现其功能。以下是关于每个组件的简要介绍：
前端组件：
firewall-cmd：firewall-cmd 是 Firewalld 的命令行前端工具，用于管理和配置防火墙规则、区域、服务等。 firewall-config：firewall-config 是一个图形化的前端工具，提供了一个易于使用的界面来配置和管理防火墙设置。 firewall-applet：firewall-applet 是 Firewalld 的系统托盘应用程序，可以在系统托盘中显示防火墙状态，并提供快速访问配置选项的功能。 firewall-offline-cmd：firewall-offline-cmd 是一个离线命令行工具，用于在没有网络连接的情况下配置和管理防火墙规则。 核心组件：<div class=read-more-link><a href=/posts/firewalld/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/chronyd/>Linux Chronyd 极简教程</a></h1><time datetime=2023-12-28T23:28:45+0800 class=post-date>December 28, 2023</time><ul class=tags><li class=tag-linux><a href=https://yezihack.github.io/tags/linux>linux</a></li><li class=tag-chronyd><a href=https://yezihack.github.io/tags/chronyd>chronyd</a></li><li class=tag-极简教程><a href=https://yezihack.github.io/tags/%E6%9E%81%E7%AE%80%E6%95%99%E7%A8%8B>极简教程</a></li></ul></div>1. 什么是 Chrony Chrony 是一款用于时钟同步的程序，它可以通过网络协议（如 NTP、UDP）与外部时间源进行通信，从而使本地系统的时钟与参考时钟保持同步。相比其他时钟同步程序，Chrony 具有更高的精度和更好的稳定性，特别适用于在网络不稳定或移动设备上使用。
以下是 Chrony 的一些主要特点：
渐进式时钟调整：Chrony 通过缓慢地调整时钟频率和偏移量来避免大幅度调整引起的系统不稳定性。 时钟纠正算法：Chrony 使用一种称为 MLE（Maximum Likelihood Estimation）的算法来计算时钟偏移量和频率误差，从而提高时钟同步的准确性和稳定性。 无需 root 权限：Chrony 可以在普通用户下运行，并且不需要 root 权限。 安全性：Chrony 支持加密和身份验证，以防止恶意攻击和数据篡改。 网络适应性：Chrony 可以根据网络延迟和时钟偏移量自适应地选择最佳的时间源。 相比 NTP 更加精准好用。推荐使用 Chrony。
总的来说，Chrony 是一款功能强大、精度高、稳定性好、安全性高的时钟同步程序，广泛用于各种 Linux 和 Unix 系统中。
2. 安装 # CentOS yum -y install chrony # Ubuntu apt -y install chrony # 开启 systemctl enable chronyd systemctl start chronyd 3. chrony.conf 配置 需要关注以下项：
设置时间源: server 设置权限: allow # 使用 pool.ntp.org 项目中的公共服务器。以server开，理论上想添加多少时间服务器都可以。 # Use public servers from the pool.<div class=read-more-link><a href=/posts/chronyd/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/helm-command/>Helm 常用命令</a></h1><time datetime=2023-11-29T18:44:25+0800 class=post-date>November 29, 2023</time><ul class=tags><li class=tag-helm><a href=https://yezihack.github.io/tags/helm>helm</a></li><li class=tag-chart><a href=https://yezihack.github.io/tags/chart>chart</a></li><li class=tag-云原生><a href=https://yezihack.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F>云原生</a></li></ul></div>1. 查看 Release # 查看当前 Default 命名空间下的 Release helm ls # 查看所有命名空间下的 Release helm ls -A # 查看指定命名空间下的 Release helm ls -n &lt;namespace> 2. 部署 helm install &lt;release-name> &lt;helm-Repository> -f values.yaml helm install &lt;release-name> &lt;helm-Repository> --set name=xxx -f values.yaml 3. 仓库 helm - 针对Kubernetes的Helm包管理器 helm repo add - 添加chart仓库 helm repo index - 基于包含打包chart的目录，生成索引文件 helm repo list - 列举chart仓库 helm repo remove - 删除一个或多个仓库 helm repo update - 从chart仓库中更新本地可用chart的信息 4. 升级&卸载&回滚 # 升级 helm upgrade -f myvalues.<div class=read-more-link><a href=/posts/helm-command/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/helm-template/>Helm Chart 模板</a></h1><time datetime=2023-11-29T18:44:17+0800 class=post-date>November 29, 2023</time><ul class=tags><li class=tag-helm><a href=https://yezihack.github.io/tags/helm>helm</a></li><li class=tag-chart><a href=https://yezihack.github.io/tags/chart>chart</a></li><li class=tag-云原生><a href=https://yezihack.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F>云原生</a></li></ul></div>1. 介绍 Chart 模板才是 Helm 的灵魂所在,学会模板才算入门 Helm,让我们一起学习吧.
2. 模板语法 模板命令要括在 {{ 和 }} 之间。
如:
apiVersion: v1 kind: ConfigMap metadata: name: {{ .Release.Name }}-configmap data: myvalue: "Hello World" 3. 内置对象 系统自带一些内置对象,可以在模板里使用.
Release： Release对象描述了版本发布本身。包含了以下对象：
Release.Name： release名称 Release.Namespace： 版本中包含的命名空间(如果manifest没有覆盖的话) Release.IsUpgrade： 如果当前操作是升级或回滚的话，该值将被设置为true Release.IsInstall： 如果当前操作是安装的话，该值将被设置为true Release.Revision： 此次修订的版本号。安装时是1，每次升级或回滚都会自增 Release.Service： 该service用来渲染当前模板。Helm里始终Helm Values： Values对象是从values.yaml文件和用户提供的文件传进模板的。默认为空
Chart： Chart.yaml文件内容。 Chart.yaml里的所有数据在这里都可以可访问的。比如 {{ .Chart.Name }}-{{ .Chart.Version }} 会打印出 mychart-0.1.0
Files： 在chart中提供访问所有的非特殊文件的对象。你不能使用它访问Template对象，只能访问其他文件。 请查看这个 文件访问部分了解更多信息
Files.Get 通过文件名获取文件的方法。 （.Files.Getconfig.ini） Files.GetBytes 用字节数组代替字符串获取文件内容的方法。 对图片之类的文件很有用 Files.Glob 用给定的shell glob模式匹配文件名返回文件列表的方法 Files.<div class=read-more-link><a href=/posts/helm-template/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/helm-tutorial/>Helm 入门学习</a></h1><time datetime=2023-11-29T16:23:40+0800 class=post-date>November 29, 2023</time><ul class=tags><li class=tag-helm><a href=https://yezihack.github.io/tags/helm>helm</a></li><li class=tag-chart><a href=https://yezihack.github.io/tags/chart>chart</a></li><li class=tag-云原生><a href=https://yezihack.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F>云原生</a></li></ul></div>1. 什么是 Helm Helm是一个Kubernetes的包管理工具，它可以帮助我们简化Kubernetes应用程序的部署和管理。使用Helm，可以将Kubernetes应用程序打包成易于安装、升级和卸载的chart包，并且可以在不同的Kubernetes环境中重复使用这些chart包。
2. Helm 三个概念 Chart 代表着 Helm 包，即模板代码的集合 Repository 用来存放和共享 charts 的地方 Release 运行在 Kubernetes 集群中的 chart 的实例 3. 安装 Helm 官方地址: https://github.com/helm/helm/releases # linux amd64 wget https://get.helm.sh/helm-v3.13.0-linux-amd64.tar.gz tar -zxvf helm-v3.13.0-linux-amd64.tar.gz cd linux-amd64 cp helm /usr/local/sbin 4. 快速入门 4.1. 添加 Repository 仓库 https://artifacthub.io/ # 添加 Helm Char 仓库 helm repo add bitnami https://charts.bitnami.com/bitnami # 查看添加的仓库列表 helm repo ls # 更新 charts 列表 helm repo update 4.2. 搜索 Chart # 搜索 charts 列表 helm search repo bitnami # 搜索指定的 charts 包名，如 nginx helm search repo nginx 4.<div class=read-more-link><a href=/posts/helm-tutorial/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/vm-share-dir/>Vmware 虚拟机共享宿主机文件夹</a></h1><time datetime=2023-10-19T17:37:26+0800 class=post-date>October 19, 2023</time><ul class=tags><li class=tag-linux><a href=https://yezihack.github.io/tags/linux>linux</a></li><li class=tag-虚拟机><a href=https://yezihack.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA>虚拟机</a></li><li class=tag-工具><a href=https://yezihack.github.io/tags/%E5%B7%A5%E5%85%B7>工具</a></li></ul></div>1. 设置共享目录 前提：必须关闭虚拟机，再点击设置
如图所示：
2. 使用共享目录 # 安装 open-vm-tools yum install -y open-vm-tools # 共享目录生效 vmhgfs-fuse /mnt/hgfs/ # 设置软链 mkdir /opt/vm-share ln -s /mnt/hgfs/vm-share/ /opt/vm-share 3. 设置开机启动 cat >> /etc/rc.local &lt;&lt;EOF vmhgfs-fuse /mnt/hgfs/ EOF</article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/haproxy-keepalived/>Haproxy + Keepalived 实现 k8s 集群高可用</a></h1><time datetime=2023-07-05T11:41:00+0800 class=post-date>July 5, 2023</time><ul class=tags><li class=tag-linux><a href=https://yezihack.github.io/tags/linux>linux</a></li><li class=tag-高可用><a href=https://yezihack.github.io/tags/%E9%AB%98%E5%8F%AF%E7%94%A8>高可用</a></li></ul></div>1. 什么是 Kubernetes 的高可用 高可用性是指系统或应用程序在面对故障或异常情况时能够保持持续运行和提供服务的能力。在构建高可用的Kubernetes集群时，可以采取以下一些高级方法和策略：
多节点部署：使用多个节点来部署Kubernetes集群，确保即使某个节点发生故障，其他节点仍然可以继续提供服务。
负载均衡：通过在集群前端引入负载均衡器，将流量分发到多个节点上，实现负载均衡和故障转移。这样即使某个节点发生故障，负载均衡器可以将流量重新路由到其他健康的节点上。
自动伸缩：利用Kubernetes的自动伸缩功能，根据实际负载情况自动调整集群的节点数量，以满足应用程序的需求。这样可以在高负载时增加节点数量，保证性能，而在低负载时减少节点数量，节省资源。
容器健康检查：通过定义容器的健康检查机制，Kubernetes可以监控容器的运行状态，并在容器出现故障或异常时自动重启或替换容器，确保应用程序的持续可用性。
数据备份和恢复：定期对关键数据进行备份，并建立可靠的数据恢复机制，以防止数据丢失或损坏。这可以通过使用Kubernetes的持久化存储卷（Persistent Volume）和备份工具来实现。
故障切换和容错：通过使用Kubernetes的故障切换功能，可以在节点或容器发生故障时自动将服务切换到备用节点或容器上，确保应用程序的连续性和可用性。
监控和告警：建立全面的监控系统，实时监测集群和应用程序的运行状态，并设置告警机制，及时发现和处理潜在的故障或异常情况。
通过采取这些高级方法和策略，可以有效地提高Kubernetes集群的可用性和稳定性，确保应用程序在运行时不会出现服务中断。
2. Haproxy + Keepalived 优缺点 Haproxy和Keepalived是常用的组合，用于实现负载均衡和高可用性的解决方案。下面是它们的优缺点：
2.1. Haproxy Haproxy的优点：
高性能：Haproxy是一个高性能的负载均衡器，能够处理大量的并发连接和请求。 灵活的配置：Haproxy提供了丰富的配置选项，可以根据需求进行灵活的负载均衡策略和规则配置。 健康检查：Haproxy支持对后端服务器进行健康检查，可以自动排除故障的服务器，确保只将请求转发到健康的服务器上。 SSL终止：Haproxy可以作为SSL终止器，将SSL/TLS连接解密后再转发给后端服务器，减轻服务器的负担。 Haproxy 的缺点：
单点故障：Haproxy本身是单点，如果Haproxy节点发生故障，可能会导致服务中断。 配置复杂：Haproxy的配置相对复杂，需要一定的学习和经验来正确配置和管理。 2.2. Keepalived Keepalived 的优点：
高可用性：Keepalived可以将多个Haproxy节点组成一个高可用集群，通过VRRP协议实现故障切换，确保服务的连续性和可用性。 快速故障切换：Keepalived能够快速检测到主节点的故障，并将VIP（虚拟IP）迅速切换到备用节点上，减少服务中断时间。 简单配置：Keepalived的配置相对简单，可以快速部署和管理。 Keepalived的缺点：
配置同步：Keepalived需要确保配置文件的同步，以保证所有节点的配置一致性，这可能需要额外的配置和管理工作。 依赖性：Keepalived依赖于底层网络和操作系统的支持，可能受限于特定的网络环境和操作系统版本。 架构图 3. Haproxy 3.1. 底层原理 Keepalived 是一种用于实现高可用性的软件，其底层原理主要包括以下几个方面：
VRRP 协议：Keepalived 使用 VRRP（Virtual Router Redundancy Protocol）协议来实现高可用性。VRRP 协议通过将多个服务器组成一个虚拟路由器组，共同提供相同的虚拟 IP 地址，实现了服务器的冗余备份和故障切换。
虚拟路由器组：多个服务器通过 Keepalived 组成一个虚拟路由器组，共同提供相同的虚拟 IP 地址。其中一个服务器被选举为主服务器（Master），其他服务器为备份服务器（Backup）。
心跳检测：主备服务器之间通过周期性的心跳消息进行通信，以检测主服务器的可用性。如果备份服务器在一定时间内没有收到主服务器的心跳消息，就会触发主备切换。
健康检查：Keepalived 支持对服务的健康检查，通过定期检查服务的可用性和性能，及时剔除故障或不可用的服务器，保证了服务的高可用性和稳定性。
路由表更新：当主服务器发生故障或不可用时，备份服务器中的一台将会被选举为新的主服务器，接管虚拟 IP 地址的转发功能。同时，Keepalived 会更新路由表，将虚拟 IP 地址指向新的主服务器。<div class=read-more-link><a href=/posts/haproxy-keepalived/>Read More…</a></div></article></div><hr><div class=footer><nav id=page-nav><span class="page-number current">1</span>
<a href=/page/2/>2</a>
<a href=/page/3/>3</a>
<a href=/page/4/>4</a>
<a href=/page/5/>5</a>
<a href=/page/6/>6</a>
<a href=/page/7/>7</a>
<a href=/page/8/>8</a>
<a href=/page/9/>9</a>
<a href=/page/10/>10</a>
<a href=/page/11/>11</a>
<a href=/page/12/>12</a>
<a href=/page/13/>13</a>
<a href=/page/14/>14</a>
<a href=/page/15/>15</a>
<a href=/page/16/>16</a>
<a href=/page/17/>17</a>
<a href=/page/18/>18</a>
<a href=/page/19/>19</a>
<a href=/page/2/ rel=next class="extend next">Next &#187;</a></div></main></div></body></html>