<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><script defer language=javascript type=text/javascript src=/js/bundle.min.14549c76bbc96f0af1574b0259efd70e52908cd36fb4d14ed3d290a1b6479eae.js></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=/favicon.png><title itemprop=name>空树之空</title><meta property="og:title" content="空树之空"><meta name=twitter:title content="空树之空"><meta itemprop=name content="空树之空"><meta name=application-name content="空树之空"><meta property="og:site_name" content="空树之空"><meta name=description content="《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes、DevOps和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。"><meta itemprop=description content="《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes、DevOps和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。"><meta property="og:description" content="《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes、DevOps和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。"><meta name=twitter:description content="《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes、DevOps和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。"><base href=https://yezihack.github.io/><link rel=canonical href=https://yezihack.github.io/ itemprop=url><meta name=url content="https://yezihack.github.io/"><meta name=twitter:url content="https://yezihack.github.io/"><meta property="og:url" content="https://yezihack.github.io/"><meta property="og:updated_time" content="5007-05-11T741:00:23+0800"><link rel=sitemap type=application/xml title=Sitemap href=https://yezihack.github.io/sitemap.xml><link href=https://yezihack.github.io/index.xml rel=alternate type=application/rss+xml title=空树之空><meta name=robots content="index,follow"><meta name=googlebot content="index,follow"><meta name=twitter:site content><meta name=twitter:creator content><meta property="fb:admins" content><meta name=apple-mobile-web-app-title content="空树之空"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta property="og:type" content="website"><meta name=author content><script defer type=application/ld+json>{"@context":"http://schema.org","@type":"Article","headline":"空树之空","author":{"@type":"Person","name":""},"datePublished":"2023-07-05","description":"","wordCount":"0","mainEntityOfPage":"True","dateModified":"2023-07-05","image":{"@type":"imageObject","url":""},"publisher":{"@type":"Organization","name":"空树之空","logo":{"@type":"imageObject","url":""}}}</script><meta name=generator content="Hugo 0.114.0"><link type=text/css rel=stylesheet href=/css/bundle.min.aa949ea27ee9836d60d6ea4c073fd0885f51948c7eea0247da6b1aff4bc25c44.css><style>body{--sidebar-bg-color:#202020;--sidebar-img-border-color:#515151;--sidebar-p-color:#909090;--sidebar-h1-color:#FFF;--sidebar-a-color:#FFF;--sidebar-socials-color:#FFF;--text-color:#222;--bkg-color:#FAF9F6;--post-title-color:#303030;--list-color:#5a5a5a;--link-color:#268bd2;--date-color:#515151;--table-border-color:#E5E5E5;--table-stripe-color:#F9F9F9;--code-color:#bf616a;--code-background-color:#E5E5E5;--moon-sun-color:#FFF;--moon-sun-background-color:#515151}body.dark-theme{--text-color:#eee;--bkg-color:#121212;--post-title-color:#DBE2E9;--list-color:#9d9d9d;--link-color:#268bd2;--date-color:#9a9a9a;--table-border-color:#515151;--table-stripe-color:#202020;--code-color:#ff7f7f;--code-background-color:#393D47}body{background-color:var(--bkg-color)}</style></head><body class=dark-theme><div class=wrapper><aside class=sidebar><div class="container sidebar-sticky"><div class=light-dark align=right><button class=btn-light-dark title="Toggle light/dark mode"><svg class="moon" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16"><path fill="currentcolor" d="M6 .278a.768.768.0 01.08.858 7.208 7.208.0 00-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527.0 1.04-.055 1.533-.16a.787.787.0 01.81.316.733.733.0 01-.031.893A8.349 8.349.0 018.344 16C3.734 16 0 12.286.0 7.71.0 4.266 2.114 1.312 5.124.06A.752.752.0 016 .278z"/></svg><svg class="sun" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16"><path fill="currentcolor" d="M8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 0zm0 13a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 13zm8-5a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2a.5.5.0 01.5.5zM3 8a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2A.5.5.0 013 8zm10.657-5.657a.5.5.0 010 .707l-1.414 1.415a.5.5.0 11-.707-.708l1.414-1.414a.5.5.0 01.707.0zm-9.193 9.193a.5.5.0 010 .707L3.05 13.657a.5.5.0 01-.707-.707l1.414-1.414a.5.5.0 01.707.0zm9.193 2.121a.5.5.0 01-.707.0l-1.414-1.414a.5.5.0 01.707-.707l1.414 1.414a.5.5.0 010 .707zM4.464 4.465a.5.5.0 01-.707.0L2.343 3.05a.5.5.0 11.707-.707l1.414 1.414a.5.5.0 010 .708z"/></svg></button></div><div class=sidebar-about><h1 class=brand><a href=https://yezihack.github.io/><img src=/images/head.jpg alt="brand image"></a>
<a href=https://yezihack.github.io/><h1>空树之空</h1></a></h1><p class=lead>《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes、DevOps和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。</p></div><nav><ul class=sidebar-nav><li class=heading><a href=/about/>About</a></li><li class=heading><a href=/posts/>Posts</a></li><li class=sub-heading>Recent</li><li class=bullet><a href=https://yezihack.github.io/posts/haproxy-keepalived.html>Haproxy + Keepalived 实现 k8s 集群高可用</a></li><li class=bullet><a href=https://yezihack.github.io/posts/istio-ratelimit.html>Istio 限流实现</a></li><li class=bullet><a href=https://yezihack.github.io/posts/istio-install.html>Istio 安装</a></li><li class=bullet><a href=https://yezihack.github.io/posts/etcd-v3.2.html>云运维笔记(10) Etcd V3.2 集群二进制搭建</a></li><li class=bullet><a href=https://yezihack.github.io/posts/etcd-v3.4.html>云运维笔记(11) Etcd V3.4 集群二进制搭建</a></li><li class=heading><a href=/tags/>Tags</a></li></ul></nav><a target=_blank class=social title=GitHub href=https://github.com/yezihack><svg xmlns="http://www.w3.org/2000/svg" width="1.2em" height="1.2em" viewBox="-2 -2 24 24"><path fill="currentcolor" d="M18.88 1.099C18.147.366 17.265.0 16.233.0H3.746C2.714.0 1.832.366 1.099 1.099.366 1.832.0 2.714.0 3.746v12.487c0 1.032.366 1.914 1.099 2.647.733.733 1.615 1.099 2.647 1.099H6.66c.19.0.333-.007.429-.02a.504.504.0 00.286-.169c.095-.1.143-.245.143-.435l-.007-.885c-.004-.564-.006-1.01-.006-1.34l-.3.052c-.19.035-.43.05-.721.046a5.555 5.555.0 01-.904-.091 2.026 2.026.0 01-.872-.39 1.651 1.651.0 01-.572-.8l-.13-.3a3.25 3.25.0 00-.41-.663c-.186-.243-.375-.407-.566-.494l-.09-.065a.956.956.0 01-.17-.156.723.723.0 01-.117-.182c-.026-.061-.004-.111.065-.15.07-.04.195-.059.378-.059l.26.04c.173.034.388.138.643.311a2.1 2.1.0 01.631.677c.2.355.44.626.722.813.282.186.566.28.852.28.286.0.533-.022.742-.065a2.59 2.59.0 00.585-.196c.078-.58.29-1.028.637-1.34a8.907 8.907.0 01-1.333-.234 5.314 5.314.0 01-1.223-.507 3.5 3.5.0 01-1.047-.872c-.277-.347-.505-.802-.683-1.365-.177-.564-.266-1.215-.266-1.952.0-1.049.342-1.942 1.027-2.68-.32-.788-.29-1.673.091-2.652.252-.079.625-.02 1.119.175.494.195.856.362 1.086.5.23.14.414.257.553.352a9.233 9.233.0 012.497-.338c.859.0 1.691.113 2.498.338l.494-.312a6.997 6.997.0 011.197-.572c.46-.174.81-.221 1.054-.143.39.98.424 1.864.103 2.653.685.737 1.028 1.63 1.028 2.68.0.737-.089 1.39-.267 1.957-.177.568-.407 1.023-.689 1.366a3.65 3.65.0 01-1.053.865c-.42.234-.828.403-1.223.507a8.9 8.9.0 01-1.333.235c.45.39.676 1.005.676 1.846v3.11c0 .147.021.266.065.357a.36.36.0 00.208.189c.096.034.18.056.254.064.074.01.18.013.318.013h2.914c1.032.0 1.914-.366 2.647-1.099.732-.732 1.099-1.615 1.099-2.647V3.746c0-1.032-.367-1.914-1.1-2.647z"/></svg></a><a target=_blank class=social title="RSS Feed" href=https://yezihack.github.io//posts/index.xml><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1.2em" viewBox="0 0 1280 1280"><g transform="translate(0.000000,1280.000000) scale(0.100000,-0.100000)" fill="currentcolor"><path d="M2295 11929c-284-12-642-45-707-65-17-5-18-63-18-1039 0-569 4-1036 8-1039 5-3 74 6 153 19 510 86 1168 95 1789 25 1348-153 2602-677 3670-1531 385-308 820-744 1126-1129 842-1060 1362-2313 1514-3650 70-621 61-1279-25-1789-13-79-22-148-19-153 3-4 471-8 1039-8h1035l5 23c51 225 85 942 67 1419-23 605-77 1044-198 1617-294 14e2-927 2734-1823 3846-1043 1295-2364 2259-3909 2854-1158 447-2451 656-3707 6e2z"/><path d="M2255 7845c-269-25-620-81-667-106-17-9-18-55-18-899 0-706 3-890 13-890 6 0 66 18 132 41 130 44 288 79 467 105 154 21 577 30 749 15 1207-107 2267-823 2814-1902 166-327 268-637 330-1001 38-227 48-384 42-662-8-348-44-590-126-831-23-66-41-126-41-132 0-10 184-13 890-13 844 0 890 1 899 18 27 50 88 452 110 725 14 162 14 624 1 782-59 703-233 1323-545 1945-481 956-1313 1788-2270 2268-620 310-1239 483-1940 542-165 14-669 10-840-5z"/><path d="M2519 3815c-391-66-725-336-868-703-79-201-96-462-45-677 83-344 338-641 666-774 116-47 205-69 330-80 412-39 811 153 1040 5e2 193 292 240 648 128 981-135 403-492 699-914 757-1e2 14-241 12-337-4z"/></g></svg></a><a target=_blank class=social title=Email href=mailto://freeit@126.com><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1.2em" viewBox="0 0 485.211 485.211"><path fill="currentcolor" d="M301.393 241.631 464.866 424.56H20.332l163.474-182.928 58.801 51.443 58.786-51.444zM462.174 60.651H23.027l219.579 192.142L462.174 60.651zM324.225 221.67l160.986 180.151V80.792L324.225 221.67zM0 80.792v321.029L160.972 221.64.0 80.792z"/></svg></a><p class=footnote><br>&copy; 2023 百里江山. All rights reserved.</p></div></aside><main class="content container"><div class=posts><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/haproxy-keepalived.html>Haproxy + Keepalived 实现 k8s 集群高可用</a></h1><time datetime=2023-07-05T11:41:00+0800 class=post-date>July 5, 2023</time><ul class=tags><li class=tag-linux><a href=https://yezihack.github.io/tags/linux>linux</a></li><li class=tag-高可用><a href=https://yezihack.github.io/tags/%E9%AB%98%E5%8F%AF%E7%94%A8>高可用</a></li></ul></div>1. 什么是 Kubernetes 的高可用 高可用性是指系统或应用程序在面对故障或异常情况时能够保持持续运行和提供服务的能力。在构建高可用的Kubernetes集群时，可以采取以下一些高级方法和策略：
多节点部署：使用多个节点来部署Kubernetes集群，确保即使某个节点发生故障，其他节点仍然可以继续提供服务。
负载均衡：通过在集群前端引入负载均衡器，将流量分发到多个节点上，实现负载均衡和故障转移。这样即使某个节点发生故障，负载均衡器可以将流量重新路由到其他健康的节点上。
自动伸缩：利用Kubernetes的自动伸缩功能，根据实际负载情况自动调整集群的节点数量，以满足应用程序的需求。这样可以在高负载时增加节点数量，保证性能，而在低负载时减少节点数量，节省资源。
容器健康检查：通过定义容器的健康检查机制，Kubernetes可以监控容器的运行状态，并在容器出现故障或异常时自动重启或替换容器，确保应用程序的持续可用性。
数据备份和恢复：定期对关键数据进行备份，并建立可靠的数据恢复机制，以防止数据丢失或损坏。这可以通过使用Kubernetes的持久化存储卷（Persistent Volume）和备份工具来实现。
故障切换和容错：通过使用Kubernetes的故障切换功能，可以在节点或容器发生故障时自动将服务切换到备用节点或容器上，确保应用程序的连续性和可用性。
监控和告警：建立全面的监控系统，实时监测集群和应用程序的运行状态，并设置告警机制，及时发现和处理潜在的故障或异常情况。
通过采取这些高级方法和策略，可以有效地提高Kubernetes集群的可用性和稳定性，确保应用程序在运行时不会出现服务中断。
2. Haproxy + Keepalived 优缺点 Haproxy和Keepalived是常用的组合，用于实现负载均衡和高可用性的解决方案。下面是它们的优缺点：
2.1. Haproxy Haproxy的优点：
高性能：Haproxy是一个高性能的负载均衡器，能够处理大量的并发连接和请求。 灵活的配置：Haproxy提供了丰富的配置选项，可以根据需求进行灵活的负载均衡策略和规则配置。 健康检查：Haproxy支持对后端服务器进行健康检查，可以自动排除故障的服务器，确保只将请求转发到健康的服务器上。 SSL终止：Haproxy可以作为SSL终止器，将SSL/TLS连接解密后再转发给后端服务器，减轻服务器的负担。 Haproxy 的缺点：
单点故障：Haproxy本身是单点，如果Haproxy节点发生故障，可能会导致服务中断。 配置复杂：Haproxy的配置相对复杂，需要一定的学习和经验来正确配置和管理。 2.2. Keepalived Keepalived 的优点：
高可用性：Keepalived可以将多个Haproxy节点组成一个高可用集群，通过VRRP协议实现故障切换，确保服务的连续性和可用性。 快速故障切换：Keepalived能够快速检测到主节点的故障，并将VIP（虚拟IP）迅速切换到备用节点上，减少服务中断时间。 简单配置：Keepalived的配置相对简单，可以快速部署和管理。 Keepalived的缺点：
配置同步：Keepalived需要确保配置文件的同步，以保证所有节点的配置一致性，这可能需要额外的配置和管理工作。 依赖性：Keepalived依赖于底层网络和操作系统的支持，可能受限于特定的网络环境和操作系统版本。 架构图 3. Haproxy 3.1. 底层原理 Keepalived 是一种用于实现高可用性的软件，其底层原理主要包括以下几个方面：
VRRP 协议：Keepalived 使用 VRRP（Virtual Router Redundancy Protocol）协议来实现高可用性。VRRP 协议通过将多个服务器组成一个虚拟路由器组，共同提供相同的虚拟 IP 地址，实现了服务器的冗余备份和故障切换。
虚拟路由器组：多个服务器通过 Keepalived 组成一个虚拟路由器组，共同提供相同的虚拟 IP 地址。其中一个服务器被选举为主服务器（Master），其他服务器为备份服务器（Backup）。
心跳检测：主备服务器之间通过周期性的心跳消息进行通信，以检测主服务器的可用性。如果备份服务器在一定时间内没有收到主服务器的心跳消息，就会触发主备切换。
健康检查：Keepalived 支持对服务的健康检查，通过定期检查服务的可用性和性能，及时剔除故障或不可用的服务器，保证了服务的高可用性和稳定性。
路由表更新：当主服务器发生故障或不可用时，备份服务器中的一台将会被选举为新的主服务器，接管虚拟 IP 地址的转发功能。同时，Keepalived 会更新路由表，将虚拟 IP 地址指向新的主服务器。<div class=read-more-link><a href=/posts/haproxy-keepalived.html>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/istio-ratelimit.html>Istio 限流实现</a></h1><time datetime=2023-06-12T15:29:48+0800 class=post-date>June 12, 2023</time><ul class=tags><li class=tag-istio><a href=https://yezihack.github.io/tags/istio>istio</a></li><li class=tag-k8s><a href=https://yezihack.github.io/tags/k8s>k8s</a></li><li class=tag-云原生><a href=https://yezihack.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F>云原生</a></li><li class=tag-限流><a href=https://yezihack.github.io/tags/%E9%99%90%E6%B5%81>限流</a></li></ul></div>1. 介绍限流 限流是一种通过对系统请求进行限制和控制，避免系统过载，保证系统稳定性和安全性的技术手段。
2. Istio 限流 首先确认需要限流的应用是否已经加载了 sidecar，如果还未安装 istio, 请参考:https://yezihack.github.io/istio-install.html 创建 app-ratelimit.yaml：
设置流速间隔时间：token_bucket.fill_interval 设置流速令牌数量：token_bucket.max_tokens 选择哪些应用限流：workloadSelector.labels apiVersion: networking.istio.io/v1alpha3 kind: EnvoyFilter metadata: name: app-ratelimit spec: workloadSelector: labels: app: my-app # 用来选择需要进行配置的工作负载 configPatches: - applyTo: HTTP_FILTER match: listener: filterChain: filter: name: "envoy.filters.network.http_connection_manager" patch: operation: INSERT_BEFORE value: name: envoy.filters.http.local_ratelimit typed_config: "@type": type.googleapis.com/udpa.type.v1.TypedStruct type_url: type.googleapis.com/envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit value: stat_prefix: http_local_rate_limiter token_bucket: # 令牌桶算法的配置信息，用于控制每秒放行的请求数量。 max_tokens: 10 # 指定令牌桶中最多可以存储的令牌数，即最大可用令牌数 tokens_per_fill: 10 # 指定每次填充令牌桶的令牌数，即每次可用令牌数。 fill_interval: 60s # 定填充令牌桶的时间间隔，即每隔多长时间填充一次令牌桶。 filter_enabled: # 控制是否启用该过滤器的开关。 runtime_key: local_rate_limit_enabled default_value: numerator: 100 denominator: HUNDRED filter_enforced: # 制是否强制执行该过滤器的开关。 runtime_key: local_rate_limit_enforced default_value: numerator: 100 denominator: HUNDRED response_headers_to_add: - append: false header: key: x-local-rate-limit value: 'true' kubectl apply -f app-ratelimit.<div class=read-more-link><a href=/posts/istio-ratelimit.html>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/istio-install.html>Istio 安装</a></h1><time datetime=2023-06-12T14:26:54+0800 class=post-date>June 12, 2023</time><ul class=tags><li class=tag-istio><a href=https://yezihack.github.io/tags/istio>istio</a></li><li class=tag-k8s><a href=https://yezihack.github.io/tags/k8s>k8s</a></li><li class=tag-云原生><a href=https://yezihack.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F>云原生</a></li></ul></div>1. Istio 介绍 Istio 是由 Google、IBM 和 Lyft 开源的微服务管理、保护和监控框架。Istio 为希腊语，意思是”起航“。
Istio 使用功能强大的 Envoy 服务代理扩展了 Kubernetes，以建立一个可编程的、可感知的应用程序网络。
Istio 与 Kubernetes 和传统工作负载一起使用，为复杂的部署带来了标准的通用流量管理、遥测和安全性。
2. 下载 istio 以 CentOS7 为例
官方下载：https://github.com/istio/istio/releases/
截止写本文时，版本更新到 v1.18.0。
2.1. 版本的选择 https://istio.io/latest/zh/docs/releases/supported-releases/
v1.18.0 适合 k8s 1.24, 1.25, 1.26, 1.27。
根据你的 kubernetes 版本进行下载相应的 istio 版本。
cd /opt/src wget https://github.com/istio/istio/releases/download/1.18.0/istio-1.18.0-linux-amd64.tar.gz tar -zxvf istio-1.18.0-linux-amd64.tar.gz cd istio-1.18.0 cp istio-1.18.0/bin/istioctl /usr/local/bin # 查看版本 istioctl version # 如果显示如下，则表示你未设置 KUBECONFIG 环境变量 unable to retrieve Pods: Get "http://localhost:8080/api/v1/namespaces/istio-system/pods?fieldSelector=status.phase%3DRunning&amp;labelSelector=app%3Distiod": dial tcp [::1]:8080: connect: connection refused 1.<div class=read-more-link><a href=/posts/istio-install.html>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/etcd-v3.2.html>云运维笔记(10) Etcd V3.2 集群二进制搭建</a></h1><time datetime=2023-05-16T11:24:46+0800 class=post-date>May 16, 2023</time><ul class=tags><li class=tag-k8s><a href=https://yezihack.github.io/tags/k8s>k8s</a></li><li class=tag-etcd><a href=https://yezihack.github.io/tags/etcd>etcd</a></li><li class=tag-etcd-3.2><a href=https://yezihack.github.io/tags/etcd-3.2>etcd-3.2</a></li></ul></div>1. 准备工作 搭建 ETCD 高可用集群，至少3台或5台或7台，奇数台即可。本地搭建采用3台 Linux CentOS7.9 环境。
序列 HOSTNAME IP etcd 节点名称 1 kube-10 192.168.9.10 etcd01 2 kube-11 192.168.9.11 etcd02 3 kube-13 192.168.9.13 etcd03 创建目录：
bin 存储 etcd 二进制文件 data 存储数据目录 sh 脚本目录 ssl 证书目录 # 每个机器上都执行 mkdir -p /opt/etcd/{bin,data,sh,ssl} 2. 证书生成 2.1. cfssl 工具 cd /opt/src # 下载 wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64 wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64 # 改名 mv cfssl_linux-amd64 cfssl mv cfssljson_linux-amd64 cfssljson mv cfssl-certinfo_linux-amd64 cfssl-certinfo # 添加执行权限 chmod +x cfssl cfssljson cfssl-certinfo # 复制到 /usr/local/bin cp cfssl cfssl-cerinfo cfssljson /usr/local/bin 2.<div class=read-more-link><a href=/posts/etcd-v3.2.html>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/etcd-v3.4.html>云运维笔记(11) Etcd V3.4 集群二进制搭建</a></h1><time datetime=2023-05-16T11:24:46+0800 class=post-date>May 16, 2023</time><ul class=tags><li class=tag-k8s><a href=https://yezihack.github.io/tags/k8s>k8s</a></li><li class=tag-etcd><a href=https://yezihack.github.io/tags/etcd>etcd</a></li><li class=tag-etcd-3.4><a href=https://yezihack.github.io/tags/etcd-3.4>etcd-3.4</a></li></ul></div>1. 准备工作 适合于 kubernetes 1.17/1.18/1.19/1.20/1.21 搭建 ETCD 高可用集群，至少3台或5台或7台，奇数台即可。本地搭建采用3台 Linux CentOS7.9 环境。
序列 HOSTNAME IP etcd 节点名称 1 kube-10 192.168.9.10 etcd01 2 kube-11 192.168.9.11 etcd02 3 kube-13 192.168.9.13 etcd03 创建目录：
bin 存储 etcd 二进制文件 data 存储数据目录 conf 配置目录 sh 脚本目录 ssl 证书目录 # 每个机器上都执行 mkdir -p /opt/etcd-3.4/{bin,data,sh,ssl,conf} 时间同步 # 安装 yum install chrony -y # 管理 systemctl start chronyd #启动 systemctl status chronyd #查看 systemctl restart chronyd #重启 systemctl stop chronyd #停止 systemctl enable chronyd #设置开机启动 # 修改时区 timedatectl set-timezone Asia/Shanghai # 设置完时区后，强制同步下系统时钟： chronyc -a makestep 设置与指定服务器时间同步<div class=read-more-link><a href=/posts/etcd-v3.4.html>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/nginx-install.html>Nginx 源码安装</a></h1><time datetime=2023-03-03T15:34:45+0800 class=post-date>March 3, 2023</time><ul class=tags><li class=tag-linux><a href=https://yezihack.github.io/tags/linux>linux</a></li><li class=tag-nginx><a href=https://yezihack.github.io/tags/nginx>nginx</a></li></ul></div>源码安装 nginx 下载 http://nginx.org/en/download.html
wget http://nginx.org/download/nginx-1.23.3.tar.gz tar -zxvf nginx-1.23.3.tar.gz cd nginx-1.23.3 修改源码版本 修改 nginx 默认的版本名称,如 nginx/1.23.3, 可任意修改为: sgfoot/100.0.0
vim src/core/nginx.h # 大约在14行左右 #define nginx_version 1023003 #define NGINX_VERSION "1.23.3" # 版本号修改 #define NGINX_VER "nginx/" NGINX_VERSION # 软件名称修改 安装 使用自定义用户和用户组,更加安全 开启模块:
with-http_ssl_module SSL模块 with-http_stub_status_module 统计功能模块,分析 nginx 性能 with-http_realip_module 获取真实IP模块 with-threads 线程池模块,提高nginx性能 with-http_gzip_static_module 开启压缩功能 yum -y install gcc pcre pcre-devel zlib zlib-devel openssl openssl-devel # 添加用户和组 groupadd www useradd -g www www # 配置 .<div class=read-more-link><a href=/posts/nginx-install.html>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/k8s-bug-pod-network.html>K8s 跨 Node 机器 Pod 网络异常</a></h1><time datetime=2023-02-07T18:07:36+0800 class=post-date>February 7, 2023</time><ul class=tags><li class=tag-异常><a href=https://yezihack.github.io/tags/%E5%BC%82%E5%B8%B8>异常</a></li><li class=tag-错误><a href=https://yezihack.github.io/tags/%E9%94%99%E8%AF%AF>错误</a></li><li class=tag-网络><a href=https://yezihack.github.io/tags/%E7%BD%91%E7%BB%9C>网络</a></li><li class=tag-云运维笔记><a href=https://yezihack.github.io/tags/%E4%BA%91%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0>云运维笔记</a></li><li class=tag-kubernetes><a href=https://yezihack.github.io/tags/kubernetes>kubernetes</a></li><li class=tag-k8s><a href=https://yezihack.github.io/tags/k8s>k8s</a></li><li class=tag-flannel><a href=https://yezihack.github.io/tags/flannel>flannel</a></li></ul></div>背景 在 k8s 里部署了应用需要通过 ingress 提供外部调用. ingressController Pod 应用部署在 A 机器上, 应用部署在 B 机器上.
通过自定义域名调用应用,则需要经过自定义域名配置的 host 的 kube-proxy 到 IngressController Pod 机器,再由 Ingress 负载找到应用的 Service 负载的 endpoint.
最终请求到应用的 Pod.
环境 k8s: 1.19 docker: 19.10 linux: CentOS7.6 分析思路 先确定 host:port 端口是否通达？ 再确认 ingress 是否可以访问到 service IP ingress 关于作者 我的博客：https://yezihack.github.io
欢迎关注我的微信公众号【空树之空】，一日不学则面目可憎也，吾学也。</article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/k8s-dispatch.html>云运维笔记(9) Kubernetes Pod 调度策略</a></h1><time datetime=2022-12-16T18:14:20+0800 class=post-date>December 16, 2022</time><ul class=tags><li class=tag-linux><a href=https://yezihack.github.io/tags/linux>linux</a></li><li class=tag-教程><a href=https://yezihack.github.io/tags/%E6%95%99%E7%A8%8B>教程</a></li><li class=tag-云运维笔记><a href=https://yezihack.github.io/tags/%E4%BA%91%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0>云运维笔记</a></li><li class=tag-调度><a href=https://yezihack.github.io/tags/%E8%B0%83%E5%BA%A6>调度</a></li><li class=tag-k8s><a href=https://yezihack.github.io/tags/k8s>k8s</a></li></ul></div>1.1. 四大调度方式 1.1.1. 自动调试 1.1.2. 定向调度 1.1.2.1. NodeName 1.1.2.2. NodeSelector 1.1.3. 亲和性调度 1.1.3.1. NodeAffinity 1.1.3.2. PodAffinity 1.1.3.3. PodAntiAffinity 1.1.4. 污点（容忍）调度 1.1.4.1. 污点 1.1.4.2. 容忍 1.2. 参考 关于作者 1.1. 四大调度方式 自动调度：运行在哪个节点上完全由Scheduler经过一系列的算法计算得出 定向调度：NodeName、NodeSelector 亲和性调度：NodeAffinity、PodAffinity、PodAntiAffinity 污点（容忍）调度：Taints、Toleration 1.1.1. 自动调试 完全交由 kube-scheduler 来决定 pod 调度到哪里，不受人为控制。
1.1.2. 定向调度 1.1.2.1. NodeName NodeName用于强制约束将Pod调度到指定的Name的Node节点上。这种方式，其实是直接跳过Scheduler的调度逻辑，直接将Pod调度到指定名称的节点。
使用实例：
apiVersion: v1 kind: Pod metadata: name: pod-nodename namespace: dev spec: nodeName: kube-11 # 指定调度到node1节点上 containers: - name: nginx image: nginx:1.17.1 tip: 这种调度不够灵活，必须指定某 node 节点，若 node 异常会导致调度失败。<div class=read-more-link><a href=/posts/k8s-dispatch.html>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/kubeadm-upgrade-v1.16.html>云运维笔记(8) Kubeadm 内网补丁版本升级，从v1.16.0至v1.16.15</a></h1><time datetime=2022-12-09T16:26:37+0800 class=post-date>December 9, 2022</time><ul class=tags><li class=tag-linux><a href=https://yezihack.github.io/tags/linux>linux</a></li><li class=tag-教程><a href=https://yezihack.github.io/tags/%E6%95%99%E7%A8%8B>教程</a></li><li class=tag-云运维笔记><a href=https://yezihack.github.io/tags/%E4%BA%91%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0>云运维笔记</a></li><li class=tag-kubeadm><a href=https://yezihack.github.io/tags/kubeadm>kubeadm</a></li><li class=tag-k8s><a href=https://yezihack.github.io/tags/k8s>k8s</a></li></ul></div>.1. 为什么升级 漏洞问题 使用新功能 .2. 特殊性 内网环境，没有外网。 多 master 集群。 外置 Etcd。 .3. 版本 kubeadm升级前版本：v1.16.0 kubeadm升级后版本：v1.16.15 .4. 升级前的检查 .4.1. 查看当前版本 kubeadm version kubeadm version: &amp;version.Info{Major:"1", Minor:"16", GitVersion:"v1.16.0", GitCommit:"72c30166b2105cd7d3350f2c28a219e6abcd79eb", GitTreeState:"clean", BuildDate:"2020-01-18T23:29:13Z", GoVersion:"go1.13.5", Compiler:"gc", Platform:"linux/amd64"} .4.2. 离线下载 kubectl,kubeadm,kubelet 下载 # 必须本机没有安装以下软件 version="1.16.15" yumdownloader --resolve --destdir=/opt/local-packages/ kubelet-${version} kubeadm-${version} kubectl-${version} .4.3. 制作共享 YUM 源 使用工具：saber
假定本机IP：192.168.10.10
# 安装 Createrepo yum install createrepo -y createrepo /opt/local-packages/ # 如果存在 repodata 则使用更新 createrepo --update /opt/local-packages/ # 共享文件 saber fs /opt/local-packages/ .<div class=read-more-link><a href=/posts/kubeadm-upgrade-v1.16.html>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/k8s-error.html>云运维笔记(7) kubernetes 错误收集</a></h1><time datetime=2022-12-07T11:31:00+0800 class=post-date>December 7, 2022</time><ul class=tags><li class=tag-异常><a href=https://yezihack.github.io/tags/%E5%BC%82%E5%B8%B8>异常</a></li><li class=tag-错误><a href=https://yezihack.github.io/tags/%E9%94%99%E8%AF%AF>错误</a></li><li class=tag-云运维笔记><a href=https://yezihack.github.io/tags/%E4%BA%91%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0>云运维笔记</a></li><li class=tag-kubernetes><a href=https://yezihack.github.io/tags/kubernetes>kubernetes</a></li><li class=tag-k8s><a href=https://yezihack.github.io/tags/k8s>k8s</a></li></ul></div>.1. 为什么 Kubernetes 众多组件汇集于一身，插件也是多如牛毛，在运维中或日常安装中难免会遇到各种各样的错误，有些错误并不好排查，让人火急火燎搜索一翻，半天已经过去。在此收集日常使用 kubernetes 遇到的问题。
.2. Ingress-nginx .2.1. Internal error occurred: failed calling webhook &ldquo;validate.nginx.ingress.kubernetes.io&rdquo; .2.1.1. 详细错误信息 Error from server (InternalError): error when creating "ingress.yaml": Internal error occurred: failed calling webhook "validate.nginx.ingress.kubernetes.io": Post "https://ingress-nginx-controller-admission.ingress-nginx.svc:443/networking/v1beta1/ingresses?timeout=10s": context deadline exceeded .2.1.2. 解决方法 删除验证
# 查看 kubectl get validatingwebhookconfigurations # 删除 kubectl delete -A ValidatingWebhookConfiguration ingress-nginx-admission .3. 关于作者 我的博客：https://yezihack.github.io
欢迎关注我的微信公众号【空树之空】，一日不学则面目可憎也，吾学也。</article></div><hr><div class=footer><nav id=page-nav><span class="page-number current">1</span>
<a href=/page/2.html>2</a>
<a href=/page/3.html>3</a>
<a href=/page/4.html>4</a>
<a href=/page/5.html>5</a>
<a href=/page/6.html>6</a>
<a href=/page/7.html>7</a>
<a href=/page/8.html>8</a>
<a href=/page/9.html>9</a>
<a href=/page/10.html>10</a>
<a href=/page/11.html>11</a>
<a href=/page/12.html>12</a>
<a href=/page/13.html>13</a>
<a href=/page/14.html>14</a>
<a href=/page/15.html>15</a>
<a href=/page/16.html>16</a>
<a href=/page/17.html>17</a>
<a href=/page/18.html>18</a>
<a href=/page/2.html rel=next class="extend next">Next &#187;</a></div></main></div></body></html>