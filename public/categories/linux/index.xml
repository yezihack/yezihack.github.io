<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>linux on</title><link>https://yezihack.github.io/categories/linux/</link><description>Recent content in linux on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 17 Feb 2022 15:36:03 +0800</lastBuildDate><atom:link href="https://yezihack.github.io/categories/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>查看 Linux 系统资源</title><link>https://yezihack.github.io/posts/linux-system-info/</link><pubDate>Thu, 17 Feb 2022 15:36:03 +0800</pubDate><guid>https://yezihack.github.io/posts/linux-system-info/</guid><description>1. 系统 uname -a # 查看系统版本全部信息 uname -r # 查看内核版本 hostname # 查看主机名称 cat /etc/redhat-release # 打印系统类型，只对红帽系统有用, 如 CentOS env # 显示环境变量 lspci # 主板信息 2. 资源 free -mh # 查看内存使用量和交换区使用量 df -h # 查看各分区使用情况 du -sh &amp;lt;目录名&amp;gt; # 查看指定目录的大小 uptime # 查看系统运行时间、用户数、负载 cat /proc/loadavg # 查看系统负载 lsblk # 树形显示硬盘结构 nvidia-smi # 显卡信息 cat /proc/cpuinfo | grep &amp;#39;model name&amp;#39; | sort | uniq # 查看CPU型号 cat /proc/cpuinfo | grep &amp;#39;physical id&amp;#39; | sort | uniq | wc -l # 查看 CPU 颗数, 实际Server中插槽上的CPU个数, 物理cpu数量 cat /proc/cpuinfo |grep &amp;#34;cores&amp;#34;|uniq|awk &amp;#39;{print $4}&amp;#39; # 查看 CPU 核数, 一颗CPU上面能处理数据的芯片组的数量。 cat /proc/cpuinfo |grep &amp;#34;processor&amp;#34;|wc -l # 逻辑CPU核数，逻辑CPU数量=物理cpu数量 x cpu cores 这个规格值 x 2(如果支持并开启超线程)。 lspci | grep -i nvidia # 查看nvidia显卡，如果没有lspci, yum -y install pciutils lspci | grep -i vga # 查看内置GPU nvidia-smi # 查看GPU watch -n 10 nvidia-smi # 动态查看GPU 3.</description></item><item><title>linux 忘记密码</title><link>https://yezihack.github.io/posts/linux-forget-password/</link><pubDate>Wed, 03 Mar 2021 15:57:12 +0800</pubDate><guid>https://yezihack.github.io/posts/linux-forget-password/</guid><description>启动 使用上下键选择不同的内核（可能有些机器就只有一个内核） 选中内核后，按e 键进入编辑状态 编辑 以下内容都是可以编辑，添加或删除的代码。（谨慎操作） 找到linux16的字符串， 然后再在本行中找到ro的字母，将其替换成rw init=/sysroot/bin/sh 然后按ctrl+x组合键，系统进入emergency(紧急情况)模式 chroot /sysroot/ # 切换回原始系统 LANG=en # 如果出现方块，不是字母的情况下设置成英文语言 passwd root # 对 root 修改密码 touch /.autorelabel # 使SELinux生效，密码生效 exit # 退出 reboot # 重启命令 关于我 我的博客：https://yezihack.github.io
欢迎关注我的微信公众号【空树之空】，共同学习，一起进步~</description></item><item><title>Iptables 防火墙基础操作(一)</title><link>https://yezihack.github.io/posts/iptables/</link><pubDate>Tue, 23 Feb 2021 11:53:51 +0800</pubDate><guid>https://yezihack.github.io/posts/iptables/</guid><description> 基于 linxu centos 7
查看防火墙 iptables 命令大小写敏感
iptables -nL 添加一条规则 添加一条开放 9090 端口的规则
# 插入最前面 iptables -I INPUT -p tcp --dport 9090 -j ACCEPT # 追加最后面 iptables -A INPUT -p tcp --dport 9090 -j ACCEPT # 插入某指定位置 iptables -I INPUT 3 -p tcp --dport 9090 -j ACCEPT 关于我 我的博客：https://yezihack.github.io
欢迎关注我的微信公众号【空树之空】，共同学习，一起进步~</description></item><item><title>解决tcp6问题</title><link>https://yezihack.github.io/posts/fix-tcp-tcp6/</link><pubDate>Sat, 19 Dec 2020 18:00:57 +0800</pubDate><guid>https://yezihack.github.io/posts/fix-tcp-tcp6/</guid><description>背景: 在 windows 上安装了 vmware linux . 在 linux 上开启一个服务对外提供8080端口, 而在 windows 上无法访问到.
解决思路 使用 netstat -nplt 查看端口上 tcp, 还是 tcp6 查看是否只绑定在 ipv6 上 sysctl net.ipv6.bindv6only 查看ipv4 上可以转发数据 : sysctl net.ipv4.ip_forward 查看防火墙是否禁用端口. 第一步: 查看端口 netstat -nplt
-&amp;gt; # netstat -nplt Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1001/sshd tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 1156/master tcp6 0 0 :::8080 :::* LISTEN 28187/output/bin/go 可以看出 8080端口只出现在 tcp6 上.</description></item><item><title>linux 制作绿色安装包</title><link>https://yezihack.github.io/posts/make-linux-green-soft/</link><pubDate>Mon, 16 Nov 2020 17:51:10 +0800</pubDate><guid>https://yezihack.github.io/posts/make-linux-green-soft/</guid><description>绿色安装包的概念来自于 win 的概念, 也就是说无需安装即可使用软件. 即为绿色安装包. 在 linux 为了方便, 我们也需要制作绿色安装包, 方便相同系统之间的 copy. 即高效又好用. 何乐不为.
你将了解到 LD_LIBRARY_PATH 的概念 ldd 是什么东西 如何制作绿色安装包 安装 mediainfo 在 CentOS7 192.168.1. 100 机器上操作.
yum -y install mediainfo 制作ldd打包脚本 本脚本用于将 mediainfo 所依赖的动态库或依赖文件都复制出来
文件名:pack.sh
#!/bin/bash set +x # 需要打包的命令全路径 file_path=$1 # 需要复制的目录 target_dir=$2 # check file path if [ ! -f $file_path ];then echo &amp;#34;$file_path is not file&amp;#34; exit 0 fi # 判断目录是否为空 if [ -z $target_dir ]; then echo &amp;#34;target_dir is null&amp;#34; exit 0 fi # 目录不存在,自动创建 if [ !</description></item><item><title>rsyslog 占用内存过高</title><link>https://yezihack.github.io/posts/fix-rsyslog/</link><pubDate>Fri, 16 Oct 2020 10:38:58 +0800</pubDate><guid>https://yezihack.github.io/posts/fix-rsyslog/</guid><description>排查问题 使用top 再按大写M， 对内存采用降序显示，一目了然看到谁占用内存最高。
定位到rsyslogd进程占用内存25.7%，非常可怕，需要急需解决掉它。
什么是rsyslog: 系统提供的多线性日志系统，参考: https://www.rsyslog.com/
解决问题 rsyslogd是它的守护进程，可以通过systemctl status rsyslog 查看运行状态
红色显示错误信息。
使用journalctl --verify 检查系统日志卷文件损坏情况
如果检查出来有红色的文件，则直接删除即可。
删除/var/lib/rsyslog/imjournal.state 文件
重启rsyslogd进程， systemctl restart rsyslog
然后使用 top 查看，内存占用率是否没有啦。
避免再次发生 修改/etc/rsyslog.conf 文件
最后行添加2行代码
$imjournalRatelimitInterval 0 $imjournalRatelimitBurst 0 重启服务:systemctl restart rsyslog
关闭 journal 压缩配置
vim /etc/systemd/journald.conf # 找到 #Compress=yes 修改成 no Compress=no # 重启服务 systemctl restart systemd-journald</description></item><item><title>fdisk lvm对根目录扩容</title><link>https://yezihack.github.io/posts/fdisk-rsync/</link><pubDate>Tue, 22 Sep 2020 20:04:14 +0800</pubDate><guid>https://yezihack.github.io/posts/fdisk-rsync/</guid><description>生产服务器根目录空间余量告急，你可能会选择对重装系统重装，这种方式对生产服务器不友好，也不推荐。网上你可以看到很多文章进行LVM进行根目录扩容，当然一顿猛操作后，发现无计于事，因为你的根目录挂载的磁盘根本不是LVM方式，无法这样操作。在不重装，也不影响线上生产，有没有一种方式可以实现动态扩容呢？答案：有
概要 使用rsync命令带属性方式转移数据 然后再使用lvm方式进行对某些目录进行重装挂载 这样就可以扩出容量。 LVM 原理 LVM的工作原理其实很简单，它就是通过将底层的物理硬盘抽象的封装起来，然后以逻辑卷的方式呈现给上层应用
掌握4个基本的逻辑卷概念
PE(Physical Extend) 物理扩展（底层） PV(Physical Volume) 物理卷（底层） VG(Volume Group) 卷组 LV(Logical Volume) 逻辑卷（上层） 工作原理
常用命令操作
# 格式为物理卷 pvcreate /dev/vda1 [可以多个] pvdisplay #查看物理卷 pvs #查看物理卷列表 # 创建卷组 vgcreate vg1 /dev/vda1 # vg1 是卷组名称， /dev/vda1 是分区名称 vgdisplay # 查看卷组 vgs # 查看卷组列表 # 创建逻辑卷 lvcreate -n lv1 -L 50G vg1 # lv1 是逻辑卷名称， 50G 是转成逻辑卷大小 vg1就是卷组 lvdisplay # 查看逻辑卷信息 lvs # 查看逻辑卷列表 实战 查看你的磁盘分区信息(df -h) 查看你的磁盘信息(fdisk -l) 对指点磁盘进行分区操作(fdisk /dev/vdc 每个人的磁盘分区名称不一样) 创建物理卷 创建卷组 创建逻辑卷 对逻辑卷进行格式化 ext4 挂载某目录 # 1.</description></item><item><title>Linux 命令集</title><link>https://yezihack.github.io/posts/linux-commands/</link><pubDate>Mon, 06 Jul 2020 18:07:38 +0800</pubDate><guid>https://yezihack.github.io/posts/linux-commands/</guid><description>文件类 查看文件大小 # 加 h 查看可读性的文件大小 ll -h # 查看文件夹大小 # --max-depth=1 表示查看文件夹的一层 du -h --max-depth=1 /usr 压缩 ZIP
-r 递归处理，将指定目录下的所有文件和子目录一并处理。 -y 直接保存符号连接，而非该连接所指向的文件，本参数仅在UNIX之类的系统下有效。 -v 显示指令执行过程或显示版本信息。 -j 只保存文件名称及其内容，而不存放任何目录名称。 -b 添加注释 -u 更新文件 # 压缩 # target.zip 是压缩后的文件名 # source-dir 要压缩的文件夹名 zip -r target.zip source-dir # 压缩保留软链, 只对类 unix 系统有效 # -y 保留软链 zip -ry target.zip source-dir # 压缩带注释 zip -ryb target.zip source-dir # 解压 unzip target.zip # 查看压缩文件, 不压缩 unzip -v target.</description></item><item><title>Top</title><link>https://yezihack.github.io/posts/top/</link><pubDate>Mon, 22 Jun 2020 10:21:47 +0800</pubDate><guid>https://yezihack.github.io/posts/top/</guid><description>top 是 linux 最常用的命令, 包括很多少直观的信息, 有利于我们对系统运行状态的把握.
top 使用 top 系统自带命令,可以直接使用.
top top 详情 a. 如图编号(1)
top - 10:34:07 up 16 min, 1 user, load average: 0.00, 0.01, 0.05 10:34:07 当前时间 up 16 min 系统运行时间, 如 16 分钟 1 user 当前登陆用户数 load average: 0.00, 0.01, 0.05 系统负载. 三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。 b. 如图编号(2)
Tasks: 206 total, 1 running, 205 sleeping, 0 stopped, 0 zombie Tasks: 206 total 进程总数 1 running 正在运行的进程数 205 sleeping 睡眠进程数 0 stopped 停止进程数 0 zombie 僵尸进程数 c.</description></item><item><title>Systemctl使用与自定义</title><link>https://yezihack.github.io/posts/systemctl/</link><pubDate>Thu, 18 Jun 2020 19:52:12 +0800</pubDate><guid>https://yezihack.github.io/posts/systemctl/</guid><description>systemd是Linux电脑操作系统之下的一套中央化系统及设置管理程序（init），包括有守护进程、程序库以及应用软件 在Unix中常以“d”作为系统守护进程（英语：daemon，亦称后台进程）的后缀标识
systemctl 命令的使用 以下以 redis 为例
启动 systemctl start redis 停止 systemctl stop redis 重启 systemctl restart redis 状态 systemctl status redis 刷新服务 systemctl daemon-reload ###　设置开机启动
systemctl enable redis 自定义配置 新建 systemctl 文件 以 redis 服务为例
touch /lib/systemd/system/redis.service
vim /lib/systemd/system/redis.service 配置文件 vim /lib/systemd/system/redis.service
[Unit]
Description=Redis
After=network.target
[Service]
Type=forking
ExecStart=/usr/local/bin/redis-server /etc/redis/redis.conf
ExecReload=/usr/local/bin/redis-server -s reload
ExecStop=/usr/local/bin/redis-server -s stop
PrivateTmp=true
Type=simple
KillMode=process
Restart=on-failure
RestartSec=3s
[Install]
WantedBy=multi-user.target [Unit] 表示这是基础信息
Description 是描述 After 是在那个服务后面启动，一般是网络服务启动后启动 [Service] 表示这里是服务信息</description></item></channel></rss>