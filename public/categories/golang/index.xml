<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on</title><link>https://yezihack.github.io/categories/golang/</link><description>Recent content in golang on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 28 Sep 2021 20:35:09 +0800</lastBuildDate><atom:link href="https://yezihack.github.io/categories/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Awesome Go</title><link>https://yezihack.github.io/posts/awesome-go/</link><pubDate>Tue, 28 Sep 2021 20:35:09 +0800</pubDate><guid>https://yezihack.github.io/posts/awesome-go/</guid><description> 收录极好的Golang库及框架，也是本人使用过，认为不错的。分享给大家。
框架类 名称 网址 Gin Web 框架 https://github.com/gin-gonic/gin Colly 爬虫框架 https://github.com/gocolly/colly 工具类 名称 网址 Gjson 动态获取JSON https://github.com/tidwall/gjson Sjson 动态设置JSON https://github.com/tidwall/sjson 关于我 我的博客：https://yezihack.github.io
欢迎关注我的微信公众号【空树之空】，共同学习，一起进步~</description></item><item><title>Systemd 管理 Golang 进程</title><link>https://yezihack.github.io/posts/systemd-golang/</link><pubDate>Mon, 15 Mar 2021 20:13:44 +0800</pubDate><guid>https://yezihack.github.io/posts/systemd-golang/</guid><description>systemd 脚本 #!/bin/bash project_name=&amp;#34;mygo&amp;#34; project_path=&amp;#34;/data/backend/&amp;#34; exec_path=&amp;#34;${project_path}${project_name}&amp;#34; cat &amp;gt; /lib/systemd/system/${project_name}.service &amp;lt;&amp;lt; EOF [Unit] Description=mygo systemd Documentation=https://yezihack.github.io After=network.target [Service] Type=simple User=root # 启动命令 ExecStart=${exec_path} # 重启命令 ExecReload=/bin/kill -SIGINT # 环境变量 Environment=&amp;#34;SGFOOT_ENV=pro&amp;#34; Environment=&amp;#34;SGFOOT_PATH=/data/conf&amp;#34; KillMode=process Restart=on-failure RestartSec=3s [Install] WantedBy=multi-user.targe EOF 管理 systemctl daemon-reload # 更新配置 systemctl start mygo # 启动 systemctl stop mygo # 停止 systemctl restart mygo # 重启 systemctl enable mygo # 加入开机启动 关于我 我的博客：https://yezihack.github.io
欢迎关注我的微信公众号【空树之空】，共同学习，一起进步~</description></item><item><title>Golang err is shadowed during return</title><link>https://yezihack.github.io/posts/fix-golang-return/</link><pubDate>Thu, 24 Dec 2020 16:11:38 +0800</pubDate><guid>https://yezihack.github.io/posts/fix-golang-return/</guid><description>复现 package main import &amp;#34;errors&amp;#34; func main() { TestErr(&amp;#34;go&amp;#34;, &amp;#34;golang&amp;#34;) } func TestErr(t, p string) (s string, err error) { switch t { case &amp;#34;go&amp;#34;: err := check(p) if err != nil { // 返回参数里的 err 作用域是整个函数,即外层作用域 // check 返回的 err 作用域是 switch 范围.即内层作用域. // return 操作,不指明是将内层作用域 返回给外层作用域, 这样在 go 里是不允许的. return } } return } func check(s string) error { if s == &amp;#34;hello&amp;#34; { return nil } return errors.</description></item><item><title>Go Mod 引用私有仓库</title><link>https://yezihack.github.io/posts/go-mod-private/</link><pubDate>Fri, 30 Oct 2020 16:01:25 +0800</pubDate><guid>https://yezihack.github.io/posts/go-mod-private/</guid><description>在做 go 开发, 如果是使用 go1.11 版本, 相信大家都会使用到 go mod 做为依赖管理, 因为 go mod 可以设置代理,国外的包,轻松下载. 但是在某一天你使用公司自建的 gitlab ,需要引用 gitlab 上面的依赖包,就需要做一些设置才会正常 go mod tidy,否则会出现无法引用的问题. 本文介绍一下如何操作.
适用于 window, linux 环境, 本人没 macOSX
你将学到:
如何设置 go mod 代理 如何设置 go env GOPRIVATE 变量 如何在代码里引用自建的 gitlab 依赖代码 设置 go mod 代理 linux, window 设置
go env -w GO111MODULE=on
go env -w GOPROXY=https://goproxy.io,direct 实践 假定私有 gitlab 仓库地址为: http://mygit.sgfoot.com/ (注意只支持http, 不支持https)
创建一个 gitlab 依赖代码 仓库地址HTTP: http://mygit.sgfoot.com/common.git 仓库地址SSH: git@mygit.</description></item><item><title>Go 并发</title><link>https://yezihack.github.io/posts/go-concurrence/</link><pubDate>Thu, 06 Aug 2020 12:01:45 +0800</pubDate><guid>https://yezihack.github.io/posts/go-concurrence/</guid><description>golang 天生语言层面支持并发, 非常棒的语言, 有时我们业务开发时, 遇到复杂场景, 需要用于并发, 将多个请求使用协程组完成并发, 当遇到嵌套循环,还存在上下文关系需要改造为并发请求, 将之前的时间复杂度为O(n^2)改为O(n)的时间复杂度, 那是否还能否并时间复杂度进一步降为O(1)呢? 就出现嵌套并发. 具体如何嵌套并发, 如何写. 今天就一步一步分析.
串行执行 时间复杂度为O(n^2) 不使用并发 结果执行时间为 9s // 串行执行 func SerializeRun() { start := time.Now() xx := []int{1, 2, 3} yy := []int{100, 200, 300} for _, x := range xx { for _, y := range yy { abc(x, y) } } fmt.Printf(&amp;#34;串行执行总时间:%s\n&amp;#34;, time.Since(start)) } func abc(x, y int) { time.Sleep(time.Second * 1) fmt.Printf(&amp;#34;x:%d, y:%d\n&amp;#34;, x, y) } 执行结果</description></item><item><title>Go 字符串指纹</title><link>https://yezihack.github.io/posts/go-fingerprint/</link><pubDate>Wed, 05 Aug 2020 15:34:32 +0800</pubDate><guid>https://yezihack.github.io/posts/go-fingerprint/</guid><description>写项目时,有时我们需要缓存, 缓存就会需要唯一的key. 常规是对字符串求md5指纹. 在golang里我们也可以使用, 目前可以计算一个字符串的crc32, md5, sha1的指纹.
md5 : 一种被广泛使用的密码散列函数，可以产bai生出一个128位（du16字节）的散列值（hash value），用于确保信息传输完整一zhi致。MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法。
sha1: SHA1是由NISTNSA设计为同DSA一起使用的，它对长度小于264的输入，产生长度为160bit的散列值，因此抗穷举(brute-force)性更好。SHA-1基于MD5，MD5又基于MD4。
crc32: 本身是“冗余校验码”的意思，CRC32则表示会产生一个32bit（8位十六进制数）的校验值。由于CRC32产生校验值时源数据块的每一个bit（位）都参与了计算，所以数据块中即使只有一位发生了变化，也会得到不同的CRC32值。
golang 实现 md5 // md5值 func Md5Str(s string) string { hash := md5.Sum([]byte(s)) return hex.EncodeToString(hash[:]) } sha1 // 散列值 func Sha1Str(s string) string { r := sha1.Sum([]byte(s)) return hex.EncodeToString(r[:]) } crc32 // String hashes a string to a unique hashcode.
// https://github.com/hashicorp/terraform/blob/master/helper/hashcode/hashcode.go
// crc32 returns a uint32, but for our use we need
// and non negative integer.</description></item><item><title>Cobra使用说明</title><link>https://yezihack.github.io/posts/cobra/</link><pubDate>Tue, 07 Jul 2020 18:54:40 +0800</pubDate><guid>https://yezihack.github.io/posts/cobra/</guid><description>Cobra 概念 Cobra有三个基本概念commands,arguments和flags。
commands代表行为
arguments代表数值
flags代表对行为的改变
例:
# clone是commands，URL是arguments，brae是flags
git clone URL --bare 使用 参考 使用 go cobra创建命令行项目</description></item><item><title>zerolog 占大量内存剖析</title><link>https://yezihack.github.io/posts/optimize-zerolog/</link><pubDate>Wed, 01 Jul 2020 19:06:01 +0800</pubDate><guid>https://yezihack.github.io/posts/optimize-zerolog/</guid><description>分析过程 使用 pprof top分析 可见 json.Marshal占第一内存. 为什么呢? 我们进一步分析
使用 tree 分析 查看到 zerolog AppendInterface 方法占用 73.32%的内存量. 而 zerolog 是一个很优秀的日志库, 比 zap 还优秀. 为什么呢?我们需要查看源码
822.70MB 73.32% | github.com/rs/zerolog/internal/json.Encoder.AppendInterface 分析源码 找到 github.com/rs/zerolog/internal/json.Encoder.AppendInterface` 366 行
// AppendInterface marshals the input interface to a string and
// appends the encoded string to the input byte slice.
func (e Encoder) AppendInterface(dst []byte, i interface{}) []byte {
marshaled, err := json.Marshal(i)
if err != nil {
return e.</description></item><item><title>Golang 单元测试/性能测试</title><link>https://yezihack.github.io/posts/golang-test/</link><pubDate>Tue, 30 Jun 2020 14:23:04 +0800</pubDate><guid>https://yezihack.github.io/posts/golang-test/</guid><description>参考 Go 单元测试/性能测试
性能测试 go test -test.bench=. -test.benchmem 指定方法 go test -test.bench=MyFunc -test.benchmem cpu 性能分析 go test -test.bench=MyFunc -test.cpuprofile cpu.out 内存分析 go test -test.bench=MyFunc -test.memprofile mem.out goroutine 阻塞分析 go test -test.bench=MyFunc -test.blockprofile block.out ###　指定几个cpu分析
go test -test.bench=MyFunc -test.benchmem -test.cpu 1,2,4</description></item><item><title>Gin_validator</title><link>https://yezihack.github.io/posts/gin_validator/</link><pubDate>Mon, 15 Jun 2020 18:35:49 +0800</pubDate><guid>https://yezihack.github.io/posts/gin_validator/</guid><description>gin 自带验证器 参考文档: https://godoc.org/gopkg.in/go-playground/validator.v8#hdr-Baked_In_Validators_and_Tags
gin 是个优秀的web框架, 集大成于一身. 对于参数的验证可以进行过滤. gin是引用了 go-playground框架, 今天我们来学习一下如何使用验证器.</description></item><item><title>golang http句柄泄露</title><link>https://yezihack.github.io/posts/curl/</link><pubDate>Thu, 11 Jun 2020 14:36:27 +0800</pubDate><guid>https://yezihack.github.io/posts/curl/</guid><description>前言 平时我们做Web开发, 经常会遇到需要请求网络资源,使用http请求, 如下面代码,注释处如果没有打开话,会导致句柄泄露, 最终报: dial tcp 127.0.0.1:80: socket: too many open files 这是为什么呢? 在linux中万物皆文件, 网络请求也相当于打开一个文件.如果打开文件忘记关闭的话, 没有及时回收资源, linux有文件打开上限,可以使用ulimit -n 查看最大支持文件打开数.
如下代码会导致句柄泄露 cli := &amp;amp;http.Client{}
req, err := http.NewRequest(http.MethodGet, &amp;#34;http://www.google.com&amp;#34;, nil)
if err != nil {
return
}
resp, err := cli.Do(req)
if err != nil {
return
}
// 必须关闭, 如果我们没有写关闭resp.Body打开的句柄,就会导致句柄泄露
// defer resp.Body.Close() // data, err := ioutil.ReadAll(resp.Body)
if err != nil {
return
}
fmt.Println(string(data))
return 分析 可以使用并发工具请求你的代码, 如使用Jmeter, 然后使用lsof -p 18001 |wc -l , 18001就你程序的进程ID, 可以查看当前程序打开文件数.</description></item><item><title>pprof火焰图分析利器之压测</title><link>https://yezihack.github.io/posts/benchmark/</link><pubDate>Tue, 09 Jun 2020 11:21:11 +0800</pubDate><guid>https://yezihack.github.io/posts/benchmark/</guid><description>Benchmark 新建测试文件 util.go文件
func GetMd5V(s string) string {
h := md5.New()
h.Write([]byte(s))
return hex.EncodeToString(h.Sum(nil))
}
func SumMd5(s string) string {
data := []byte(s)
return fmt.Sprintf(&amp;#34;%x&amp;#34;, md5.Sum(data))
} 以_test结尾的文件, 如util_test.go
func BenchmarkSumMd5(b *testing.B) {
for i := 0; i &amp;lt; b.N; i++ {
SumMd5(&amp;#34;1&amp;#34;)
}
}
func BenchmarkGetMd5V(b *testing.B) {
for i := 0; i &amp;lt; b.N; i++ {
GetMd5V(&amp;#34;1&amp;#34;)
}
} 运行Benchmark函数 go test -bench=&amp;#34;.&amp;#34; -benchmem 输出结果 BenchmarkSumMd5-8 1719777 847 ns/op 64 B/op 3 allocs/op
BenchmarkGetMd5V-8 1861362 644 ns/op 184 B/op 5 allocs/op
PASS
ok openapi/app/util 4.</description></item><item><title>pprof火焰图性能分析利器之入门</title><link>https://yezihack.github.io/posts/pprof/</link><pubDate>Fri, 05 Jun 2020 19:16:31 +0800</pubDate><guid>https://yezihack.github.io/posts/pprof/</guid><description>前言 如果你的应用是一直运行的，比如 web 应用，那么可以使用 net/http/pprof 库，它能够在提供 HTTP 服务进行分析。而非一直运行的程序可以使用 runtime/pprof 库
可以先看下pprof入门
go1.10自带 go tool pprof工具
go version 查看golang版本
安装 引用包_ &amp;quot;net/http/pprof&amp;quot;
内置包的路径: net\http\pprof\pprof.go
const (
PProfPort = 6060 // 端口
)
func PprofServer() {
runtime.SetMutexProfileFraction(1) // 开启对锁调用的跟踪
runtime.SetBlockProfileRate(1) // 开启对阻塞操作的跟踪
go func() {
err := http.ListenAndServe(fmt.Sprintf(&amp;#34;:%d&amp;#34;, PProfPort), nil)
if err != nil {
zlog.Warn().Err(err).Msg(&amp;#34;BootPprof&amp;#34;)
}
}()
}
func main() {
PprofServer()
select{}
} 浏览器查看 allocs 查看内存分配详情 block 同步原语阻塞的堆栈跟踪 cmdline 当前程序运行的参数 goroutine 所有当前goroutines的堆栈跟踪 heap 活动对象的内存分配的抽样 mutex 争用互斥锁的持有者的堆栈跟踪 profile CPU配置文件, 还可以使用go tool pprof 查看某时间段的cpu情况, 并生成火焰图 go tool pprof http://localhost:6060/debug/pprof/profile?</description></item><item><title>golang select用法</title><link>https://yezihack.github.io/posts/select/</link><pubDate>Fri, 05 Jun 2020 10:59:18 +0800</pubDate><guid>https://yezihack.github.io/posts/select/</guid><description>select 用于chan通道专用的控制结构
ch := make(chan bool)
select {
case c &amp;lt;- ch:
fmt.Println(&amp;#34;hello world&amp;#34;)
default:
return
} 使用误区 39行, return 会一直阻塞? 希望大神解释下? 答: return相当于返回,不再继续,将永远阻塞,直到主程序退出.一般用于结束这个goroutine才加上return,否则不要轻易使用. 如果return 换成break或continue就不会阻塞 package main
import (
&amp;#34;fmt&amp;#34;
&amp;#34;github.com/gin-gonic/gin&amp;#34;
&amp;#34;log&amp;#34;
&amp;#34;math/rand&amp;#34;
&amp;#34;sync&amp;#34;
)
type Cache struct {
ch chan int
}
var (
_cache *Cache
_once sync.Once
)
func NewCache() *Cache {
_once.Do(func() {
_cache = &amp;amp;Cache{
ch: make(chan int, 10),
}
_cache.monitor()
})
return _cache
}
func (c *Cache) Push(x int) {
c.</description></item><item><title>Goz学习笔记</title><link>https://yezihack.github.io/posts/goz/</link><pubDate>Tue, 28 Apr 2020 20:33:51 +0800</pubDate><guid>https://yezihack.github.io/posts/goz/</guid><description>分析 项目四个Go文件, 每个文件仅描述一件事, 思路非常清淅, 故此学习并总结一下里面的精华.
定义Options结构体接受外部定义的配置 定义入口文件, 整个项目的入口, 并返回一个下一层处理的结构体 定义逻辑结构体, 下一层结构体担负着处理逻辑的任务,并返回处理结构的结构体. 定义收尾结构体, 将上一层的处理的结果进行进一步分析,最终展现给用户 入口文件 Goz.go 只初使化了Request结构体. 可以定义初使配置Options, 整个项目所需的配置都在Options结构里 options.go#L6 // NewClient new request object func NewClient(opts ...Options) *Request { req := &amp;amp;Request{} if len(opts) &amp;gt; 0 { req.opts = opts[0] } return req } 配置文件 Options.go 定义了整个项目需要的外部参数 变量首字母都大写 options.go#L6 // Options object type Options struct { BaseURI string Timeout float32 timeout time.Duration Query interface{} Headers map[string]interface{} Cookies interface{} FormParams map[string]interface{} JSON interface{} Proxy string } 核心处理文件 Request.</description></item></channel></rss>