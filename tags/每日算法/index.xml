<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>每日算法 on 空树之空</title><link>https://yezihack.github.io/tags/%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95/</link><description>Recent content in 每日算法 on 空树之空</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 14 Apr 2020 21:22:39 +0800</lastBuildDate><atom:link href="https://yezihack.github.io/tags/%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>算法第6天:跳水板</title><link>https://yezihack.github.io/posts/algo-6-day/</link><pubDate>Tue, 14 Apr 2020 21:22:39 +0800</pubDate><guid>https://yezihack.github.io/posts/algo-6-day/</guid><description>leetcode: 16.11 https://leetcode-cn.com/problems/diving-board-lcci
题目 你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。
返回的长度需要从小到大排列。
思路 题目的意思就是求一个k的组合, 利用给出的长短木板进行组合.
边界条件考虑:
如果k = 0, 也就是不需要组合.返回空数组.
如果长短目录都相等, 最长的目录组就是 k * 长度(shorter, longer)
代码求解 func LivingBoard(shorter, longer, k int) []int { if k == 0 { // 也就是不需要组合.返回空数组. return nil } if shorter == longer { // 如果长短目录都相等, 最长的目录组就是 k * 长度(shorter, longer) return []int{shorter * k} } group := make([]int, k+1) // 为什么k+1, 因为在组合中我可以使用全是长木板也可以使用全是短木板. for i := 0; i &amp;lt; k+1; i++ { fmt.</description></item><item><title>算法第5天:最大子序和</title><link>https://yezihack.github.io/posts/algo-5-day/</link><pubDate>Mon, 24 Feb 2020 15:16:57 +0800</pubDate><guid>https://yezihack.github.io/posts/algo-5-day/</guid><description>leetcode 53. 最大子序和 simple
题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
解题思路 共三种思路: 暴力求解;贪心算法,动态规划
暴力求解 数组每一种组合都查看一遍, 每个组合都与保存当前最大值的变量比较一下.
//暴力求解
//Time:O(n^2), space:O(1)
func MaxSubArray(nums []int) int {
count := len(nums)
if count == 0 {
return 0
}
max := 0
for i := 0; i &amp;lt; count; i++ {
sum := 0
for j := i; j &amp;lt; count; j++ {
sum += nums[j] //累加操作
if sum &amp;gt; max { //如果大于max则替换掉.</description></item><item><title>算法第4天:LRU缓存机制</title><link>https://yezihack.github.io/posts/algo-4-day/</link><pubDate>Mon, 24 Feb 2020 15:16:54 +0800</pubDate><guid>https://yezihack.github.io/posts/algo-4-day/</guid><description>leetcode 146. LRU缓存机制 middle
题目 运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。 写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。
进阶: 你是否可以在 O(1) 时间复杂度内完成这两种操作？ 解题方法 采用hash+double-linked实现LRU缓存算法机制. 先独立写个双链表, 然后引用双链表和hash实现LRU
双链表 有些多除的方法,主要为了调试使用.
type Linkeder interface {
AddHead(key, value int) *LinkedNode //插入头位置
Append(key, value int) *LinkedNode //追求到尾部
RemoveNode(node *LinkedNode) bool //删除指定位置的节点
RemoveTail() *LinkedNode //删除尾部的节点
Reverse() *LinkedNode //反转链表
Print() string //打印链表
PrintLink(head *LinkedNode) string
}
type LinkedNode struct {
key int //key
value int //value
next *LinkedNode //next pointer
prev *LinkedNode //prev pointer
}
type Linked struct {
length int //链表长度
head *LinkedNode //链表头部节点
tail *LinkedNode //链表尾部节点
}
func NewLinked() Linkeder {
return &amp;amp;Linked{}
}
//插入头部操作.</description></item><item><title>算法第3天:最长公共前缀</title><link>https://yezihack.github.io/posts/algo-3-day/</link><pubDate>Mon, 24 Feb 2020 15:16:51 +0800</pubDate><guid>https://yezihack.github.io/posts/algo-3-day/</guid><description>leetcode 14. 最长公共前缀 simple
题目 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &amp;ldquo;&amp;quot;。
输入: [&amp;ldquo;flower&amp;rdquo;,&amp;ldquo;flow&amp;rdquo;,&amp;ldquo;flight&amp;rdquo;] 输出: &amp;ldquo;fl&amp;rdquo;
输入: [&amp;ldquo;dog&amp;rdquo;,&amp;ldquo;racecar&amp;rdquo;,&amp;ldquo;car&amp;rdquo;] 输出: &amp;quot;&amp;rdquo; 解释: 输入不存在公共前缀。
解题思路 解法一: 挨个比较 首先要注意边界条件, 数组为空的情况 先找到数组里最短的字符串,因为题目是求最短前缀,必须先找最短的字符串 拿最短字符串与数组里每一个字符串的每一个字符进行比较. 如果不相等则截取,即获取最短前缀. 注意这里是最外层循环是最短的字符串循环, 然后里层循环是数组循环, 挨个字符串进行比较. 也就是查看所有的字符串与最短的字符串是否一致.如果出现不一致则截取返回. func LongestCommonPrefix(strs []string) string {
l := len(strs)
if l == 0 { //边界条件
return &amp;#34;&amp;#34;
}
short := strs[0]
//从数组里查找到最小字符串.
for i := 1; i &amp;lt; l; i++ {
if len(short) &amp;gt; len(strs[i]) { //只要存在比第一个字符还短的则进行赋值操作.
short = strs[i]
}
}
//如果最短字符串长度为0则,返回空
if len(short) == 0 { //边界条件 .</description></item><item><title>算法第1天: 缺失的第一个正数</title><link>https://yezihack.github.io/posts/algo-1-day/</link><pubDate>Mon, 24 Feb 2020 11:21:11 +0800</pubDate><guid>https://yezihack.github.io/posts/algo-1-day/</guid><description>感触 为了坚持学习算法, 每篇算法标题写上坚持多少天,以此鼓励自己坚持学下去. 会把自己理解的都写在代码处, 你在看代码时也方便, 为什么这一行这么写. 也是锻炼自己的文档水平.
题目 LeetCode:41题, 困难
给定一个未排序的整数数组，找出其中没有出现的最小的正整数。
示例 1:
输入: [1,2,0]
输出: 3
示例 2:
输入: [3,4,-1,1]
输出: 2
示例 3:
输入: [7,8,9,11,12]
输出: 1 要求: 你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间
解法一: 利用map+for-range实现 Time: O(n), Space:O(n)不符合题目要求
//解法一: 利用map+for-range实现.时间复杂度O(n), 空间是常数O(n) // 4 ms 2.8 MB func FirstMissingPositive(nums []int) int { hash := make(map[int]struct{}, len(nums)) for i := 0; i &amp;lt; len(nums); i++ { hash[nums[i]] = struct{}{} } fmt.Println(hash) //1-n之间检查, 如果有缺失则是最小值. for i := 1; i &amp;lt;= len(nums); i++ { //从1循环到n, 包含n if _, ok := hash[i]; !</description></item><item><title>算法第2天: 盛最多水的容器</title><link>https://yezihack.github.io/posts/algo-2-day/</link><pubDate>Mon, 24 Feb 2020 11:21:11 +0800</pubDate><guid>https://yezihack.github.io/posts/algo-2-day/</guid><description>LeetCode:11题, 中等
解析题目 解析题目: 将数组想象成一个矩形, 寻找这个矩形盛最多水的大小. 决定盛水高度取决于最低的那根木板.也就是数字最小的那个值, 决定盛水最多还得取决于它的长度.也就是数组的头与尾之间的距离.
暴力求解. 对数组从小到大都查看一遍, 取最大容器的那个.
//暴力求解
//Time:O(n^2), Space:O(1)
func ContainerWithMostWater(height []int) int {
if len(height) == 0 {
return 0
}
//暴力求解, 任何可能都不放过.
maxArea := 0 //存放最大面积的变量.
for i := 0; i &amp;lt; len(height); i++ {
for j := i + 1; j &amp;lt; len(height); j++ {
//获取最短板的那个数字,也就是最小值的数字
minHeight := height[i]
if height[j] &amp;lt; minHeight {
minHeight = height[j]
}
//获取j与i之间的差距离.
distance := j - i
//求面积.</description></item></channel></rss>