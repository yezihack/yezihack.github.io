<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>网络 on 空树之空</title><link>https://yezihack.github.io/tags/%E7%BD%91%E7%BB%9C/</link><description>Recent content in 网络 on 空树之空</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 07 Feb 2023 18:07:36 +0800</lastBuildDate><atom:link href="https://yezihack.github.io/tags/%E7%BD%91%E7%BB%9C/index.xml" rel="self" type="application/rss+xml"/><item><title>K8s 跨 Node 机器 Pod 网络异常</title><link>https://yezihack.github.io/posts/k8s-bug-pod-network/</link><pubDate>Tue, 07 Feb 2023 18:07:36 +0800</pubDate><guid>https://yezihack.github.io/posts/k8s-bug-pod-network/</guid><description>背景 在 k8s 里部署了应用需要通过 ingress 提供外部调用. ingressController Pod 应用部署在 A 机器上, 应用部署在 B 机器上.
通过自定义域名调用应用,则需要经过自定义域名配置的 host 的 kube-proxy 到 IngressController Pod 机器,再由 Ingress 负载找到应用的 Service 负载的 endpoint.
最终请求到应用的 Pod.
环境 k8s: 1.19 docker: 19.10 linux: CentOS7.6 分析思路 先确定 host:port 端口是否通达？ 再确认 ingress 是否可以访问到 service IP ingress 关于作者 我的博客：https://yezihack.github.io
欢迎关注我的微信公众号【空树之空】，一日不学则面目可憎也，吾学也。</description></item><item><title>Linux DNS 略解</title><link>https://yezihack.github.io/posts/dns/</link><pubDate>Mon, 25 Apr 2022 09:58:14 +0800</pubDate><guid>https://yezihack.github.io/posts/dns/</guid><description>DNS 域名系统
DNS 全称：Domain Name System
域名系统相当于一个“翻译官”，将域名翻译成对应的IP地址，然后再请求目标IP。
Linux 设置 DNS /etc/resolv 设置DNS无须重新网络，立即生效。
cat /etc/resolv.conf search github.com options timeout:1 attempts:1 rotate nameserver 192.168.1.1 nameserver 192.168.1.2 nameserver 192.168.1.3 解释 nameserver:dns服务器的ip地址。最多能设三个。
timeout:查询一个nameserver的超时时间，单位是秒。系统缺省是5，最大可以设为30。 attempts:这个是查询的整个都尝试一遍的次数。缺省是2。 rotate:这个参数的含义是随机选取一个作为首选查询的dns server。系统缺省是从上到下的。 DNS 排障方法 经常会出现某域名不通，需要使用 nslookup 工具诊断
# 安装 yum -y install nslookup -&amp;gt; % nslookup www.github.com Server: 114.114.114.114 Address: 114.114.114.114#53 Non-authoritative answer: www.github.com canonical name = github.com. Name: github.com Address: 20.205.243.166</description></item><item><title>Tcp/Ip</title><link>https://yezihack.github.io/posts/tcp-ip/</link><pubDate>Wed, 08 Jul 2020 09:30:34 +0800</pubDate><guid>https://yezihack.github.io/posts/tcp-ip/</guid><description>1. 什么是TCP/IPP 1.1. 什么网络协议 网络协议是一组用于网络上的计算机(或其他设备)之间通信的规则和数据格式的集合.
1.2. TCP/IP 在internel和很多其他网络上使用的网络协议族.
1.3. 端口 端口是用来将数据路由到适当网络应用程序的逻辑通道
1.4. DNS 负责将域名映射为IP地址
1.5. 路由器 通过逻辑地址来转发数据的一种网络设备,并且也可以将大型网络分为几个较小的子网.也可以 将一个局域子网从较大的网络中分离出来.
2. TCP/IP如何工作 2.1. tcp/ip四层模型 应用层: 提供网络排错设施,文件传输,远程控制和其他基于网络的工具,此外它还提供应用程序用来访问网络的API 传输层: 提供错误检测,流量控制,确认服务 网际层: 为数据报提供逻辑寻址和路由 网络访问层: 提供物理硬件的接口. 2.2. OSI七层模型 应用层: 为应用程序提供网络接口,支持文件传输,通信等功能的网络应用 表示层:把数据转换为标准格式,管理数据加密与压缩 会话层: 在计算机通信应用程序之间建立会话 传输层: 为网络提供错误控制和数据流控制 网络层: 支持逻辑寻址与路由选择. 数据链路层: 提供与网络适配器相连的接口,维护子网的逻辑链接 物理层:将数据转换为传输介质上的电子流或模拟脉冲,并且监视数据的传输 2.3. 哪一层处理帧 网络访问层.
2.4. 每一层封装数据的真实含义? 在发送端. 数据向下传输到下一层之前,会先在数据中附加一个特定层的报头.
在接收端，数据的还原需要进行一个封装的反过程，从物理层向上直到应用层，随着数据逐层向上传递，协议数据单元的报头及报尾被一层层剥离。
最终实现了数据从发送端到接收端的传递。
2.5. TCP 传输控制协议 传输层中一个可靠的, 面向连接的协议. 面向连接的协议提供更复杂的流量控制和错误控制, 相比UDP更可靠.因额外需要错误检查,所以比UDP慢
2.6. UDP 用户数据报协议 传输层中一个不可靠的,无连接的协议.比TCP快, 它把错误控制的责任推给了应用.</description></item></channel></rss>