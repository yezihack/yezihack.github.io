<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>pprof on 空樹之空的博客</title><link>/tags/pprof.html</link><description>Recent content in pprof on 空樹之空的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>&lt;a href='https://www.sgfoot.com'>空樹之空&lt;/a></copyright><lastBuildDate>Wed, 01 Jul 2020 19:06:01 +0800</lastBuildDate><atom:link href="/tags/pprof/index.xml" rel="self" type="application/rss+xml"/><item><title>zerolog 占大量内存剖析</title><link>/optimize-zerolog.html</link><pubDate>Wed, 01 Jul 2020 19:06:01 +0800</pubDate><guid>/optimize-zerolog.html</guid><description>分析过程 使用 pprof top分析 可见 json.Marshal占第一内存. 为什么呢? 我们进一步分析 使用 tree 分析 查看到 zerolog AppendInterface 方法占用 73.32%的内存量. 而</description></item><item><title>pprof火焰图分析利器之压测</title><link>/benchmark.html</link><pubDate>Tue, 09 Jun 2020 11:21:11 +0800</pubDate><guid>/benchmark.html</guid><description>Benchmark 新建测试文件 util.go文件 1 2 3 4 5 6 7 8 9 10 11 func GetMd5V(s string) string { h := md5.New() h.Write([]byte(s)) return hex.EncodeToString(h.Sum(nil)) } func SumMd5(s string) string { data := []byte(s) return fmt.Sprintf(&amp;#34;%x&amp;#34;, md5.Sum(data)) } 以_test结尾的文件, 如util_t</description></item><item><title>pprof火焰图性能分析利器之入门</title><link>/pprof.html</link><pubDate>Fri, 05 Jun 2020 19:16:31 +0800</pubDate><guid>/pprof.html</guid><description>前言 如果你的应用是一直运行的，比如 web 应用，那么可以使用 net/http/pprof 库，它能够在提供 HTTP 服务进行分析。而非一直运行的程序可以使用 runtime/pprof 库 可以先看下pprof入</description></item></channel></rss>