<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on 空樹之空的博客</title><link>/tags/golang.html</link><description>Recent content in golang on 空樹之空的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>&lt;a href='https://www.sgfoot.com'>空樹之空&lt;/a></copyright><lastBuildDate>Tue, 28 Sep 2021 20:35:09 +0800</lastBuildDate><atom:link href="/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Awesome Go</title><link>/awesome-go.html</link><pubDate>Tue, 28 Sep 2021 20:35:09 +0800</pubDate><guid>/awesome-go.html</guid><description>收录极好的Golang库及框架，也是本人使用过，认为不错的。分享给大家。 框架类 名称 网址 Gin Web 框架 https://github.com/gin-gonic/gin Colly 爬虫框架 https://github.com/gocolly/colly 工具类 名称 网址 Gjson 动态获取JSON</description></item><item><title>Jenkins 构建及回滚任务</title><link>/jenkins-build-rollback.html</link><pubDate>Wed, 03 Feb 2021 14:47:04 +0800</pubDate><guid>/jenkins-build-rollback.html</guid><description>以 golang 构建项目为例。 新建任务 输入一个任务名称 选择：构建一个自由风格的软件项目 可选：也可以复制已创建的任务 确定提交 配置 再次编辑刚创建的任务 描述 对</description></item><item><title>Go 优雅追踪堆栈错误包</title><link>/go-library-error.html</link><pubDate>Thu, 21 Jan 2021 14:42:08 +0800</pubDate><guid>/go-library-error.html</guid><description>Golang tracks stack error package. 优雅追踪堆栈错误包 安装(Install) 1 go get github.com/yezihack/e 介绍(Introduction) github.com/yezihack/e 项目是一个优雅地追踪你的堆栈信息.方便存储日志里</description></item><item><title>Golang err is shadowed during return</title><link>/fix-golang-return.html</link><pubDate>Thu, 24 Dec 2020 16:11:38 +0800</pubDate><guid>/fix-golang-return.html</guid><description>复现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import &amp;#34;errors&amp;#34; func main() { TestErr(&amp;#34;go&amp;#34;, &amp;#34;golang&amp;#34;) } func TestErr(t, p string) (s string, err error) { switch t { case &amp;#34;go&amp;#34;: err := check(p) if err != nil { // 返回参数里的 err 作</description></item><item><title>Go Mod 引用私有仓库</title><link>/go-mod-private.html</link><pubDate>Fri, 30 Oct 2020 16:01:25 +0800</pubDate><guid>/go-mod-private.html</guid><description>在做 go 开发, 如果是使用 go1.11 版本, 相信大家都会使用到 go mod 做为依赖管理, 因为 go mod 可以设置代理,国外的包,轻松下载. 但是在某一天你使用公司自建的 gitlab ,</description></item><item><title>Go 实践教程-gRPC-流实例(八)</title><link>/tutorial-grpc-stream-simple.html</link><pubDate>Wed, 21 Oct 2020 14:20:48 +0800</pubDate><guid>/tutorial-grpc-stream-simple.html</guid><description>你将会学到 一个完整的gRPC流实例，包括单向流与双向流的操作 如何实现gRPC流服务端代码 如何实现gRPC流客户端代码 准备 新建一个文件夹 go-grpc-simple-stream 在g</description></item><item><title>Go 实践教程-gRPC-简单实例(七)</title><link>/tutorial-grpc-simple.html</link><pubDate>Wed, 21 Oct 2020 14:20:39 +0800</pubDate><guid>/tutorial-grpc-simple.html</guid><description>你将会学到 一个完整的gRPC实例 如何实现gRPC服务端代码 如何实现gRPC客户端代码 准备 新建一个文件夹 go-grpc-simple 在go-grpc-simple文件夹</description></item><item><title>Go 实践教程-gRPC-Protobuf(六)</title><link>/tutorial-grpc-protobuf.html</link><pubDate>Wed, 21 Oct 2020 14:20:32 +0800</pubDate><guid>/tutorial-grpc-protobuf.html</guid><description>Protobuf 是 Protobuf Buffers 的简称，它是 Google 公司开发的一种数据描述语言，并于2008年开源。 可用作为设计安全的跨语言 RPC 接口的基础工具。 目前 Protobuf 已经发展到第3版本，即</description></item><item><title>Go 实践教程-gRPC-简介(五)</title><link>/tutorial-grpc-base.html</link><pubDate>Wed, 21 Oct 2020 14:18:34 +0800</pubDate><guid>/tutorial-grpc-base.html</guid><description>什么是gRPC RPC 是远程过程调用 (Remote Procedure Call)的缩写。在 RPC 中，客户端应用程序可以直接调用不同机器上的服务器应用程序上的方法，就像它是本地对象一</description></item><item><title>Go 实践教程-基本语法(四)</title><link>/tutorial-golang-base.html</link><pubDate>Tue, 29 Sep 2020 17:29:55 +0800</pubDate><guid>/tutorial-golang-base.html</guid><description>本篇主要介绍，基本数据类型、控制语句和数据结构及函数、方法、接口等知识。为后面学习打下基础，有个基本的认识。也为您将来进阶做准备。 基础语法 之</description></item><item><title>Go 实践教程-工具及运行(三)</title><link>/tutorial-golang-runing.html</link><pubDate>Wed, 16 Sep 2020 16:45:10 +0800</pubDate><guid>/tutorial-golang-runing.html</guid><description>经过前面二篇 Go 简介,Go 环境配置 学习，大家对 Golang 有个大概的了解了， 环境也配置好了，就差上手写代码啦，今天主要介绍 Golang 的开发工具与工具链，如何写出</description></item><item><title>Go 实践教程-安装及环境配置(二)</title><link>/tutorial-golang-install.html</link><pubDate>Fri, 11 Sep 2020 18:10:11 +0800</pubDate><guid>/tutorial-golang-install.html</guid><description>本教程基于 Go1.11版本展开， 也就是官方提供 Go Module 功能。 安装 Golang 国内推荐下载点 Go 语言中文网 ，默认大家使用 CPU Amd 64 架构 最新版本：go1.15.2 Window</description></item><item><title>Go 实践教程-简介(一)</title><link>/tutorial-golang-info.html</link><pubDate>Fri, 11 Sep 2020 18:10:03 +0800</pubDate><guid>/tutorial-golang-info.html</guid><description>为什么写这个教程 Golang在中国发展非常不错，国内关于 Golang 的书籍也挺多，网上的 Golang 教程也不在少数。为什么我还要重复造这个轮子呢？我自学 Golang 也是看</description></item><item><title>Go 并发</title><link>/go-concurrence.html</link><pubDate>Thu, 06 Aug 2020 12:01:45 +0800</pubDate><guid>/go-concurrence.html</guid><description>golang 天生语言层面支持并发, 非常棒的语言, 有时我们业务开发时, 遇到复杂场景, 需要用于并发, 将多个请求使用协程组完成并发, 当遇到嵌套循环,还存在上</description></item><item><title>Go 字符串指纹</title><link>/go-fingerprint.html</link><pubDate>Wed, 05 Aug 2020 15:34:32 +0800</pubDate><guid>/go-fingerprint.html</guid><description>写项目时,有时我们需要缓存, 缓存就会需要唯一的key. 常规是对字符串求md5指纹. 在golang里我们也可以使用, 目前可以计算一个字符串的c</description></item><item><title>Cobra使用说明</title><link>/cobra.html</link><pubDate>Tue, 07 Jul 2020 18:54:40 +0800</pubDate><guid>/cobra.html</guid><description>Cobra 概念 Cobra有三个基本概念commands,arguments和flags。 commands代表行为 arguments代表数值 flags</description></item><item><title>zerolog 占大量内存剖析</title><link>/optimize-zerolog.html</link><pubDate>Wed, 01 Jul 2020 19:06:01 +0800</pubDate><guid>/optimize-zerolog.html</guid><description>分析过程 使用 pprof top分析 可见 json.Marshal占第一内存. 为什么呢? 我们进一步分析 使用 tree 分析 查看到 zerolog AppendInterface 方法占用 73.32%的内存量. 而</description></item><item><title>Url Values Opimize</title><link>/optimize-url-values.html</link><pubDate>Wed, 01 Jul 2020 17:58:24 +0800</pubDate><guid>/optimize-url-values.html</guid><description/></item><item><title>Golang 单元测试/性能测试</title><link>/golang-test.html</link><pubDate>Tue, 30 Jun 2020 14:23:04 +0800</pubDate><guid>/golang-test.html</guid><description>参考 Go 单元测试/性能测试 性能测试 1 go test -test.bench=. -test.benchmem 指定方法 1 go test -test.bench=MyFunc -test.benchmem cpu 性能分析 1 go test -test.bench=MyFunc -test.cpuprofile cpu.out 内存分析 1 go test -test.bench=MyFunc -test.memprofile mem.out goroutine 阻塞分析 1 go test -test.bench=MyFunc -test.blockprofile block.out ### 指定几个cpu</description></item><item><title>Optimize Http Response Body</title><link>/optimize-http-response-body.html</link><pubDate>Tue, 30 Jun 2020 11:34:21 +0800</pubDate><guid>/optimize-http-response-body.html</guid><description/></item><item><title>io.ReadAll优化</title><link>/optimize-make_slice.html</link><pubDate>Tue, 30 Jun 2020 11:05:28 +0800</pubDate><guid>/optimize-make_slice.html</guid><description>解析方案 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 替换 ioutil.ReadAll func ReadAll(data io.ReadCloser) (body []byte) { buffer := bytes.NewBuffer(make([]byte, 0, 65536)) io.Copy(buffer, data) temp := buffer.Bytes() length := len(temp) if cap(temp) &amp;gt; (length + length/10) { body = make([]byte, length) copy(body, temp) } else { body = temp } return } 参考 [gola</description></item><item><title>Goland 提高效率的技巧</title><link>/goland-tips.html</link><pubDate>Wed, 17 Jun 2020 11:31:17 +0800</pubDate><guid>/goland-tips.html</guid><description>工欲善其事, 必先利其器 添加 Go MOD File-&amp;gt;Settings-&amp;gt;Go-&amp;gt;Go Modules 填写 goproxy: GOPROXY=https://goproxy.cn,direct 结构体添加 tags File-&amp;gt;Settings-&amp;gt;Editor-&amp;gt;Live Templates -&amp;gt; Go 复制一个 tag 新建一个 &amp;ldquo;gorm&amp;rdquo; 使用 保存时并格式代码 File-&amp;gt;Settings-&amp;gt;Tools-&amp;gt;File Watchers 选择 go fmt</description></item><item><title>Gin_validator</title><link>/gin_validator.html</link><pubDate>Mon, 15 Jun 2020 18:35:49 +0800</pubDate><guid>/gin_validator.html</guid><description>gin 自带验证器 参考文档: https://godoc.org/gopkg.in/go-playground/validator.v8#hdr-Baked_In_Validators_and_Tags gin 是个优秀的web框架, 集大成于一身. 对于参数的验证可以进行过滤. gin是引用了 go-playground框架, 今天</description></item><item><title>golang http句柄泄露</title><link>/curl.html</link><pubDate>Thu, 11 Jun 2020 14:36:27 +0800</pubDate><guid>/curl.html</guid><description>前言 平时我们做Web开发, 经常会遇到需要请求网络资源,使用http请求, 如下面代码,注释处如果没有打开话,会导致句柄泄露, 最终报: dial tcp 127.0.0.1:80: socket: too</description></item><item><title>pprof火焰图分析利器之压测</title><link>/benchmark.html</link><pubDate>Tue, 09 Jun 2020 11:21:11 +0800</pubDate><guid>/benchmark.html</guid><description>Benchmark 新建测试文件 util.go文件 1 2 3 4 5 6 7 8 9 10 11 func GetMd5V(s string) string { h := md5.New() h.Write([]byte(s)) return hex.EncodeToString(h.Sum(nil)) } func SumMd5(s string) string { data := []byte(s) return fmt.Sprintf(&amp;#34;%x&amp;#34;, md5.Sum(data)) } 以_test结尾的文件, 如util_t</description></item><item><title>pprof火焰图性能分析利器之入门</title><link>/pprof.html</link><pubDate>Fri, 05 Jun 2020 19:16:31 +0800</pubDate><guid>/pprof.html</guid><description>前言 如果你的应用是一直运行的，比如 web 应用，那么可以使用 net/http/pprof 库，它能够在提供 HTTP 服务进行分析。而非一直运行的程序可以使用 runtime/pprof 库 可以先看下pprof入</description></item><item><title>golang select用法</title><link>/select.html</link><pubDate>Fri, 05 Jun 2020 10:59:18 +0800</pubDate><guid>/select.html</guid><description>select 用于chan通道专用的控制结构 1 2 3 4 5 6 7 ch := make(chan bool) select { case c &amp;lt;- ch: fmt.Println(&amp;#34;hello world&amp;#34;) default: return } 使用误区 39行, return 会一直阻塞? 希望大神解释下? 答: return相</description></item><item><title>Go Package优秀的包</title><link>/go-package.html</link><pubDate>Wed, 13 May 2020 14:40:23 +0800</pubDate><guid>/go-package.html</guid><description>Go 资源汇总 文件 微服务 缓存 日志&amp;amp;调试 池 WEB框架 测试框架 配置 唯一ID 网络 工具包 Go 资源汇总 收集的资源大而全，提供更多选择，更大视野。 Github 描</description></item><item><title>Golang学习资源收集</title><link>/golang-study.html</link><pubDate>Fri, 08 May 2020 14:43:48 +0800</pubDate><guid>/golang-study.html</guid><description>Golang 系列进阶文章 Golang 系列文章 来源: 飞雪无情 Go包管理 Go开发工具 Go Doc 文档 Go 数组 Go 切片 Go Map Go 类型 Go 函数方法 Go 接口 Go 嵌入类型 Go 标志符可见性 Go goroutine Go 并发</description></item><item><title>Goz学习笔记</title><link>/goz.html</link><pubDate>Tue, 28 Apr 2020 20:33:51 +0800</pubDate><guid>/goz.html</guid><description>分析 项目四个Go文件, 每个文件仅描述一件事, 思路非常清淅, 故此学习并总结一下里面的精华. 定义Options结构体接受外部定义的配置 定义入口文</description></item><item><title>Golang持续集成服务之Travis教程</title><link>/golang-travis.html</link><pubDate>Fri, 24 Apr 2020 20:19:39 +0800</pubDate><guid>/golang-travis.html</guid><description>为什么使用集成服务呢 我们向github提交代码时, 我们得保证我们的代码是能运行的, 我们会写测试用例, 保证我们的代码功能能正常使用.常见大神们</description></item><item><title>github-webhook工具实现github自动构建</title><link>/github-webhook.html</link><pubDate>Fri, 24 Apr 2020 15:04:27 +0800</pubDate><guid>/github-webhook.html</guid><description>原理 当本地git push origin master向Github远程仓库提交代码时，可以通过配置github自带webhook向服务器发送请求， 利用githu</description></item><item><title>Go命令行下星号代替输入内容</title><link>/gopass.html</link><pubDate>Fri, 17 Apr 2020 19:34:16 +0800</pubDate><guid>/gopass.html</guid><description>(图片来自网络,有侵权,联系我删除) 当我们做命令行工具时, 遇到用户需要输入密码时, 常规处理是当字符串显示输入,这样并不是很好.应该像mysq</description></item><item><title>算法第6天:跳水板</title><link>/algo-6-day.html</link><pubDate>Tue, 14 Apr 2020 21:22:39 +0800</pubDate><guid>/algo-6-day.html</guid><description>leetcode: 16.11 https://leetcode-cn.com/problems/diving-board-lcci 题目 你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正</description></item><item><title>算法第5天:最大子序和</title><link>/algo-5-day.html</link><pubDate>Mon, 24 Feb 2020 15:16:57 +0800</pubDate><guid>/algo-5-day.html</guid><description>leetcode 53. 最大子序和 simple 题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释:</description></item><item><title>算法第4天:LRU缓存机制</title><link>/algo-4-day.html</link><pubDate>Mon, 24 Feb 2020 15:16:54 +0800</pubDate><guid>/algo-4-day.html</guid><description>leetcode 146. LRU缓存机制 middle 题目 运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数</description></item><item><title>算法第3天:最长公共前缀</title><link>/algo-3-day.html</link><pubDate>Mon, 24 Feb 2020 15:16:51 +0800</pubDate><guid>/algo-3-day.html</guid><description>leetcode 14. 最长公共前缀 simple 题目 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &amp;ldquo;&amp;quot;。 输入: [&amp;ldquo;flower&amp;rdquo;,&amp;ldquo;flow&amp;rdquo;,&amp;ldquo;flight&amp;rdquo;] 输出</description></item><item><title>算法第1天: 缺失的第一个正数</title><link>/algo-1-day.html</link><pubDate>Mon, 24 Feb 2020 11:21:11 +0800</pubDate><guid>/algo-1-day.html</guid><description>感触 为了坚持学习算法, 每篇算法标题写上坚持多少天,以此鼓励自己坚持学下去. 会把自己理解的都写在代码处, 你在看代码时也方便, 为什么这一行这么写</description></item><item><title>算法第2天: 盛最多水的容器</title><link>/algo-2-day.html</link><pubDate>Mon, 24 Feb 2020 11:21:11 +0800</pubDate><guid>/algo-2-day.html</guid><description>LeetCode:11题, 中等 解析题目 解析题目: 将数组想象成一个矩形, 寻找这个矩形盛最多水的大小. 决定盛水高度取决于最低的那根木板.也就是数</description></item></channel></rss>