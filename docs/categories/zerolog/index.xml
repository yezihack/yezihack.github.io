<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>zerolog on</title><link>https://yezihack.github.io/categories/zerolog/</link><description>Recent content in zerolog on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 01 Jul 2020 19:06:01 +0800</lastBuildDate><atom:link href="https://yezihack.github.io/categories/zerolog/index.xml" rel="self" type="application/rss+xml"/><item><title>zerolog 占大量内存剖析</title><link>https://yezihack.github.io/posts/optimize-zerolog/</link><pubDate>Wed, 01 Jul 2020 19:06:01 +0800</pubDate><guid>https://yezihack.github.io/posts/optimize-zerolog/</guid><description>分析过程 使用 pprof top分析 可见 json.Marshal占第一内存. 为什么呢? 我们进一步分析
使用 tree 分析 查看到 zerolog AppendInterface 方法占用 73.32%的内存量. 而 zerolog 是一个很优秀的日志库, 比 zap 还优秀. 为什么呢?我们需要查看源码
822.70MB 73.32% | github.com/rs/zerolog/internal/json.Encoder.AppendInterface 分析源码 找到 github.com/rs/zerolog/internal/json.Encoder.AppendInterface` 366 行
// AppendInterface marshals the input interface to a string and
// appends the encoded string to the input byte slice.
func (e Encoder) AppendInterface(dst []byte, i interface{}) []byte {
marshaled, err := json.Marshal(i)
if err != nil {
return e.</description></item></channel></rss>