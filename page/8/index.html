<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><script defer language=javascript type=text/javascript src=/js/bundle.min.14549c76bbc96f0af1574b0259efd70e52908cd36fb4d14ed3d290a1b6479eae.js></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=/favicon.png><title itemprop=name>空树之空</title><meta property="og:title" content="空树之空"><meta name=twitter:title content="空树之空"><meta itemprop=name content="空树之空"><meta name=application-name content="空树之空"><meta property="og:site_name" content="空树之空"><meta name=description content="《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes、DevOps和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。"><meta itemprop=description content="《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes、DevOps和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。"><meta property="og:description" content="《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes、DevOps和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。"><meta name=twitter:description content="《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes、DevOps和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。"><base href=https://yezihack.github.io/><link rel=canonical href=https://yezihack.github.io/ itemprop=url><meta name=url content="https://yezihack.github.io/"><meta name=twitter:url content="https://yezihack.github.io/"><meta property="og:url" content="https://yezihack.github.io/"><meta property="og:updated_time" content="28012-28-11T1228:45:23+0800"><link rel=sitemap type=application/xml title=Sitemap href=https://yezihack.github.io/sitemap.xml><link href=https://yezihack.github.io/index.xml rel=alternate type=application/rss+xml title=空树之空><meta name=robots content="index,follow"><meta name=googlebot content="index,follow"><meta name=twitter:site content><meta name=twitter:creator content><meta property="fb:admins" content><meta name=apple-mobile-web-app-title content="空树之空"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta property="og:type" content="website"><meta name=author content><script defer type=application/ld+json>{"@context":"http://schema.org","@type":"Article","headline":"空树之空","author":{"@type":"Person","name":""},"datePublished":"2023-12-28","description":"","wordCount":"0","mainEntityOfPage":"True","dateModified":"2023-12-28","image":{"@type":"imageObject","url":""},"publisher":{"@type":"Organization","name":"空树之空","logo":{"@type":"imageObject","url":""}}}</script><meta name=generator content="Hugo 0.114.0"><link type=text/css rel=stylesheet href=/css/bundle.min.aa949ea27ee9836d60d6ea4c073fd0885f51948c7eea0247da6b1aff4bc25c44.css><style>body{--sidebar-bg-color:#202020;--sidebar-img-border-color:#515151;--sidebar-p-color:#909090;--sidebar-h1-color:#FFF;--sidebar-a-color:#FFF;--sidebar-socials-color:#FFF;--text-color:#222;--bkg-color:#FAF9F6;--post-title-color:#303030;--list-color:#5a5a5a;--link-color:#268bd2;--date-color:#515151;--table-border-color:#E5E5E5;--table-stripe-color:#F9F9F9;--code-color:#bf616a;--code-background-color:#E5E5E5;--moon-sun-color:#FFF;--moon-sun-background-color:#515151}body.dark-theme{--text-color:#eee;--bkg-color:#121212;--post-title-color:#DBE2E9;--list-color:#9d9d9d;--link-color:#268bd2;--date-color:#9a9a9a;--table-border-color:#515151;--table-stripe-color:#202020;--code-color:#ff7f7f;--code-background-color:#393D47}body{background-color:var(--bkg-color)}</style></head><body class=dark-theme><div class=wrapper><aside class=sidebar><div class="container sidebar-sticky"><div class=light-dark align=right><button class=btn-light-dark title="Toggle light/dark mode"><svg class="moon" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16"><path fill="currentcolor" d="M6 .278a.768.768.0 01.08.858 7.208 7.208.0 00-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527.0 1.04-.055 1.533-.16a.787.787.0 01.81.316.733.733.0 01-.031.893A8.349 8.349.0 018.344 16C3.734 16 0 12.286.0 7.71.0 4.266 2.114 1.312 5.124.06A.752.752.0 016 .278z"/></svg><svg class="sun" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16"><path fill="currentcolor" d="M8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 0zm0 13a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 13zm8-5a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2a.5.5.0 01.5.5zM3 8a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2A.5.5.0 013 8zm10.657-5.657a.5.5.0 010 .707l-1.414 1.415a.5.5.0 11-.707-.708l1.414-1.414a.5.5.0 01.707.0zm-9.193 9.193a.5.5.0 010 .707L3.05 13.657a.5.5.0 01-.707-.707l1.414-1.414a.5.5.0 01.707.0zm9.193 2.121a.5.5.0 01-.707.0l-1.414-1.414a.5.5.0 01.707-.707l1.414 1.414a.5.5.0 010 .707zM4.464 4.465a.5.5.0 01-.707.0L2.343 3.05a.5.5.0 11.707-.707l1.414 1.414a.5.5.0 010 .708z"/></svg></button></div><div class=sidebar-about><h1 class=brand><a href=https://yezihack.github.io/><img src=/images/head.jpg alt="brand image"></a>
<a href=https://yezihack.github.io/><h1>空树之空</h1></a></h1><p class=lead>《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes、DevOps和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。</p></div><nav><ul class=sidebar-nav><li class=heading><a href=/about/>About</a></li><li class=heading><a href=/posts/>Posts</a></li><li class=sub-heading>Recent</li><li class=bullet><a href=https://yezihack.github.io/posts/chronyd/>Linux Chronyd 极简教程</a></li><li class=bullet><a href=https://yezihack.github.io/posts/helm-command/>Helm 常用命令</a></li><li class=bullet><a href=https://yezihack.github.io/posts/helm-template/>Helm Chart 模板</a></li><li class=bullet><a href=https://yezihack.github.io/posts/helm-tutorial/>Helm 入门学习</a></li><li class=bullet><a href=https://yezihack.github.io/posts/vm-share-dir/>Vmware 虚拟机共享宿主机文件夹</a></li><li class=heading><a href=/tags/>Tags</a></li></ul></nav><a target=_blank class=social title="RSS Feed" href=https://yezihack.github.io//posts/index.xml><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1.2em" viewBox="0 0 1280 1280"><g transform="translate(0.000000,1280.000000) scale(0.100000,-0.100000)" fill="currentcolor"><path d="M2295 11929c-284-12-642-45-707-65-17-5-18-63-18-1039 0-569 4-1036 8-1039 5-3 74 6 153 19 510 86 1168 95 1789 25 1348-153 2602-677 3670-1531 385-308 820-744 1126-1129 842-1060 1362-2313 1514-3650 70-621 61-1279-25-1789-13-79-22-148-19-153 3-4 471-8 1039-8h1035l5 23c51 225 85 942 67 1419-23 605-77 1044-198 1617-294 14e2-927 2734-1823 3846-1043 1295-2364 2259-3909 2854-1158 447-2451 656-3707 6e2z"/><path d="M2255 7845c-269-25-620-81-667-106-17-9-18-55-18-899 0-706 3-890 13-890 6 0 66 18 132 41 130 44 288 79 467 105 154 21 577 30 749 15 1207-107 2267-823 2814-1902 166-327 268-637 330-1001 38-227 48-384 42-662-8-348-44-590-126-831-23-66-41-126-41-132 0-10 184-13 890-13 844 0 890 1 899 18 27 50 88 452 110 725 14 162 14 624 1 782-59 703-233 1323-545 1945-481 956-1313 1788-2270 2268-620 310-1239 483-1940 542-165 14-669 10-840-5z"/><path d="M2519 3815c-391-66-725-336-868-703-79-201-96-462-45-677 83-344 338-641 666-774 116-47 205-69 330-80 412-39 811 153 1040 5e2 193 292 240 648 128 981-135 403-492 699-914 757-1e2 14-241 12-337-4z"/></g></svg></a><p class=footnote><br>&copy; 2023 百里江山. All rights reserved.</p></div></aside><main class="content container"><div class=posts><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/how-to-read-a-book/>如何阅读一本书(一)</a></h1><time datetime=2021-01-27T19:53:05+0800 class=post-date>January 27, 2021</time><ul class=tags><li class=tag-读书笔记><a href=https://yezihack.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0>读书笔记</a></li><li class=tag-社会科学><a href=https://yezihack.github.io/tags/%E7%A4%BE%E4%BC%9A%E7%A7%91%E5%AD%A6>社会科学</a></li></ul></div>阅读的艺术 阅读是一件主动的事，而非被动。
阅读的误区 太多的资讯就如同太少的资讯一样, 都是一种对理解力的阻碍.
我们在这个互联网上接触的到的音频,视频及文章等等, 都是一些经过太精心的设计, 使得思考形同没有需要了, 长期接受这样的信息会对我们的理解力产生阻碍.
tip: 远离二手信息, 直击源头知识.
主动的阅读 阅读越主动, 效果越好.
任务一种阅读都是一种活动, 那就必须要有一些主动的活力. 完全被动, 就阅读不了&ndash; 我们不可能在双眼停滞, 头脑昏睡的状况下阅读.
第一提醒读者: 阅读可以是一件主动的事. 第二提醒读者: 阅读越主动, 效果越好. 一个读者更主动一些, 在阅读的世界里探索能就更强一些, 收获更多一些, 因而也更高明一些.
读者对他自己, 以及面前的书籍, 要求的越多, 获得的就越多.
阅读的目标 以获得知识而读, 以及为求得理解而读.
一本书摆在你面前, 想要与你沟通一些想法. 你要能成功地阅读这本书, 完全看你能接获多少作者要要传达的讯息.
只有一种方式是真正地在阅读:
没有任何外力的帮助, 你就是要读这本书. 你什么都没有, 只凭着内心的力量, 玩味着眼前的字句, 慢慢地提升自己,从只有模糊的概念到更清楚地理解为止. 这样的一种提升, 是在阅读时的一种脑力活动, 也是更高的阅读技巧. 这种阅读就是让一本书向你即有的理解力做挑战。
两种不同意义的阅读:
第一种：阅读网文, 杂志, 公众号等, 凭我们的阅读技巧与聪明才智, 一下子便融会贯通. 这样的读物能增加我们的资讯, 却不能增进我们的理解力。 因为在开始阅读之前， 我们的理解力就已经与他们完全相当了。 否则我们一路读下去会被卡壳的。 第二种：试着读某样一开始并不怎么了解的东西。这个东西的水平就是比阅读的人高上一截。这个作者想要表达的东西， 能增进读者的理解力。 增进理解而阅读的两种状况：
第一是一开始时不相等的理解程度。 其次，阅读的人一定要把不相等的理解力克服到一定程度之内。一旦达到相同的理解程序，就完成了清楚的沟通。 tip: 我们只能从比我们"更高"的人身上学习。我们一定要知道他们是谁， 如何跟他们学习。<div class=read-more-link><a href=/posts/how-to-read-a-book/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/gof-solid/>设计模式-SOLID五大原则(十)</a></h1><time datetime=2021-01-25T21:03:38+0800 class=post-date>January 25, 2021</time><ul class=tags><li class=tag-设计模式><a href=https://yezihack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F>设计模式</a></li><li class=tag-教程><a href=https://yezihack.github.io/tags/%E6%95%99%E7%A8%8B>教程</a></li></ul></div>[TOC]
SOLID原则包括单一职责，开闭原则，里氏替换原则，接口隔离原则，依赖倒置原则。
单一职责原则(SRP) SRP: Single Responsibility Principle
A class or module should have a single reponsilibility.一个类或者模块只负责完成一个职责(或者功能)
一个类只负责完成一个职责或功能, 也就是说, 不要设计大而全的类, 要设计粒度小, 功能单一的类.
换个角度来讲就是. 一个类包含了两个或两个以上业务不相干的功能, 我们就说它的职责不够单一, 应该将它拆分成多个功能更加单一, 粒度更细的类.
如何判断类是否单一 类中的代码行数,函数或者属性过多. 类依赖的其它类过多, 或者依赖类的其它类过多, 不符合高内聚, 低耦合的设计思想. 私有方法过多 比较难给类起一个合适的名字 类中大量的方法都是集中操作类中的某几个属性. 如何设计单一类 技巧: 持续重构. 没有一尘不变的设计
单一职责原则通过避免设计大而全的类, 避免将不相关的功能耦合在一起, 来提高类的内聚性. 同时类职责单一, 类依赖和被依赖的其它类也会变少, 减少了代码的耦合性, 以此来实现代码的高内聚, 低耦合.
但是, 如果拆分得过细, 实际上会适得其反, 反倒会降低内聚性, 也会影响代码的可维护性.
开闭原则(OCP) OCP: Open Closed Priciple
Software entities (modules, classes, functions, etc.) should be open for extension, but closed for modification.<div class=read-more-link><a href=/posts/gof-solid/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/badge/>GitHub 徽章制作</a></h1><time datetime=2021-01-22T14:23:07+0800 class=post-date>January 22, 2021</time><ul class=tags><li class=tag-徽章><a href=https://yezihack.github.io/tags/%E5%BE%BD%E7%AB%A0>徽章</a></li><li class=tag-工具><a href=https://yezihack.github.io/tags/%E5%B7%A5%E5%85%B7>工具</a></li></ul></div>很早前写过一篇关于Golang持续集成服务之Travis教程, 今天再写写关于 github 上常见的徽章是如何制作的. 让你的开源项目更高大上, 让你的代码也更健壮.
徽章的含意 当你浏览一个开源项目时,看到各种徽章, 有些徽章是直接反应这个开源库的质量和完整性等等.
如上图所示
第一个徽章即 Github 自带的 workflow 提供的持续集成(CI)和持续部署(CD), 官方称之为 Actions, 图示显示为 CI, CD 是否通过 第二个徽章即 Codecov 是一个测试结果分析工具, 图标显示测试覆盖率. 第三个徽章即 shields.io 一个可以自定义徽章的网站 第四个徽章即 goreportcard 是一个项目综合评分网站 第五个徽章即 gitter 自定义讨论组的网站 CI&amp;CD 徽章 github 于2018. 10月推荐 GitHub Actions 持续集成服务, 在此之前大家都是使用 https://travis-ci.org/ 持续集成服务, 之前我也写过相关文章. Golang持续集成服务之Travis教程.
持续集成和持续部署目前 github 官方自带支持, 官方称之为 GitHub Actions.
只要你在 github 上创建一个开源项目仓库就自带 Actions 功能, 支持各种语言. 还可以自动发布 GitHub Pages 等功能, 十分强大.
如何使用可以参考阮一峰写的GitHub Actions 入门教程
关于GO的持续集成服务模板参考:
使用 GitHub Actions 后会在你的项目里自带生成一个.<div class=read-more-link><a href=/posts/badge/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/go-library-error/>Go 优雅追踪堆栈错误包</a></h1><time datetime=2021-01-21T14:42:08+0800 class=post-date>January 21, 2021</time><ul class=tags><li class=tag-golang><a href=https://yezihack.github.io/tags/golang>golang</a></li><li class=tag-每日一库><a href=https://yezihack.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93>每日一库</a></li><li class=tag-Go库><a href=https://yezihack.github.io/tags/go%E5%BA%93>Go库</a></li></ul></div>Golang tracks stack error package. 优雅追踪堆栈错误包
安装(Install) go get github.com/yezihack/e 介绍(Introduction) github.com/yezihack/e 项目是一个优雅地追踪你的堆栈信息.方便存储日志里. 而且还扩展了error包,自定义 code,msg 信息.
特色(Features) 优雅地追踪堆栈错误信息
基于github.com/pkg/errors包进行封装 支持 code, msg 自定义错误码和错误信息 方便存储日志json文件 堆栈信息以人性化展示 文档(Documentation) https://godoc.org/github.com/yezihack/e
简单使用(Use) package main import ( "github.com/yezihack/e" "log" ) func foo() error { return e.New("foo") } func main() { err := foo() if err != nil { // 需要判断是否是自定义error, 否则无法输出堆栈信息. if e.Assert(err) { log.Println(e.Convert(err).ToStr()) // 输出字符串形式 log.Println(e.Convert(err).ToArr()) // 输出数组形式 } else { log.Println(err) // 系统的 error } } } 与原堆栈信息对比 github.<div class=read-more-link><a href=/posts/go-library-error/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/gof-ddd/>设计模式-充血模式(九)</a></h1><time datetime=2021-01-14T14:37:12+0800 class=post-date>January 14, 2021</time><ul class=tags><li class=tag-设计模式><a href=https://yezihack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F>设计模式</a></li><li class=tag-教程><a href=https://yezihack.github.io/tags/%E6%95%99%E7%A8%8B>教程</a></li></ul></div>充血模式即领域驱动设计(Domain Driven Design, 简称 DDD)
贫血模式 在之前我们写一篇关于贫血模式的文章, 点击查看.
贫血模式是目前主流的一种开发模式, 基于MVC结构的开发模式.
MVC三层架构中
M 表示 Model 即数据层 V 表示 View 即展示层 C 表示 Controller 即逻辑层 做为后端开发MVC有所调整
1. Model 层 负责数据访问
2. Service层 负责业务逻辑
3. Controller层 负责暴露接口</article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/kids-piaget/>孩子是如何认识世界的?</a></h1><time datetime=2021-01-13T15:21:16+0800 class=post-date>January 13, 2021</time><ul class=tags><li class=tag-发展心理学><a href=https://yezihack.github.io/tags/%E5%8F%91%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%A6>发展心理学</a></li><li class=tag-心理学><a href=https://yezihack.github.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6>心理学</a></li></ul></div>让.皮亚杰 瑞士人，近代最有名的发展心理学家，他的认知发展学成为了这个学科的典范。
20世纪最伟大的心理学家. 与弗洛伊德称为心理学史上两位巨人。
主要贡献是对儿童的心理发展做了全面的解释, 不同于成熟论与外铄论, 这些理论都不足以让人信服, 直到让.皮亚杰提出认识发展理论提出.也称之为建构主义.
皮亚杰认为孩子的认知不是被动的,而是个体与环境相互交互的时候形成的, 孩子们都是天生的科学家与哲学家. 他们有一套非常神奇的认识外界的方法. 就象小树苗一样是有所选择的接受外界的营养.
理论 图式理论 认知发展的核心理论.
孩子从婴儿时期什么也不懂, 只知道喝奶, 这叫遗传图式, 而有一个人总是给他喂奶, 建立起妈妈的概念, 妈妈就是总喂奶的那个人. 就这样通过外界不断刺激下建构成自己的一个一个的图式.
图式主要是通过外界对自身的刺激在自己的大脑里形成一个个概念, 即是建构图式
Tip: 图式具有对客体信息进行整理,归类.改造和创造功能,以使主体有效地适应环境.
同化理论 同化过程是对图式量的提升
同化是指遇到外界刺激后他们尝试着使用自己的这个图式去理解外界, 希望把外界纳入到原有的图式之中. 这个过程称之为同化
例:　如对狗的认识, 如吉娃娃狗的图式概念, 知道他长着四条脚, 一个尾巴, 会旺旺的叫, 下次遇到哈士奇, 就会使用这个图式解释他,也就是说他会把这个图式进行同化成为之前图式的一部分, 图式也得到的发展与巩固. 但是遇到一只猫时, 他使用同样的方式解释时, 妈妈告诉他这不是一条狗, 是一只猫. 这个时候孩子就混乱啦, 然后旁边的妈妈解释给他听, 猫的嘴巴上有长长的胡须, 还会喵喵的叫, 这个叫猫. 此时孩子会在大脑中重新构建新的图式概念, 这个过程是一种顺应.
同化是一个非常重要的概念, 只有对一个图式不断的同化,得到量的积累, 才会得以建立更加完善, 更加巩固. 成年人学习一个新知识也是一样, 需要不断的同化过程, 也就是需要做相关练习, 多加应用, 得到更多的同化过程, 你的知识图式才会更加牢固完美.
同化过程是对图式量的提升
Tip: 中国俗语称: 熟能生巧.
顺应理论 构建新图式的过程
外界的刺激不可能永远可以用同样的图式去解释，顺应是指同化失败后, 产生混乱时重新构建新的图式的一个过程. 如上面所说的猫的认识过程.<div class=read-more-link><a href=/posts/kids-piaget/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/engineer-law/>工程师-定律(三)</a></h1><time datetime=2021-01-12T09:42:28+0800 class=post-date>January 12, 2021</time><ul class=tags><li class=tag-工程师><a href=https://yezihack.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%B8%88>工程师</a></li></ul></div>朴实定律 程序应该熟悉的常用定律法则
二八定律 二八定律是指在任何一组东西中, 最重要的只占其中一小部分, 约20%. 其余80%尽管是多数, 却是次要的.
如世界上的财富分配也属于二八定律, 20%人的撑握着世界80%的财富.
工程定律 海恩法则 是德国飞机涡轮机的发明者德国人帕布斯.海恩提出的一个在航空界关于飞行安全的法则.
海恩法则: 指任务不安全事故都是可以预防的.
海恩法则强调两点:
一是事故的发生是量的积累的结果 二是再好的技术, 再完美的规章, 在实际操作层面, 也无法取代人自身的素质和责任心. Tip: 软件行业也是如些, 生产上的程序出现故障, 也符合海恩法则.
墨菲定律 事情往往会向你所想到的不好的方向发展.只要有这个可能性.
比如你衣袋里有两把钥匙, 一把是房间的, 一把是车的, 如果你现在想拿车钥匙, 会发生什么呢?是的, 你往往是拿错了房间钥匙.
Tip: 如果做某项工作有多种方法, 而其中一种方法将导致事故, 那么一定有人会按这种方法去做.
康威定律 设计系统的架构受制于产生这些设计的组织的沟通结构
&mdash; M.Conway
即系统设计本质上反映了企业的组织机构.
系统各个模块间的接口也反映了企业各个部门之间的信息流动和合作方式.
Tip: 系统设计的结构必定反映其团队的组织结构
管理定律 SMART 原则 Smart 原则是目标管理中的一种方法.
由五个字母组成
S (Specific) 明确性: 指目标必须是明确的, 具体的.不能笼统. M (Measurable) 可衡量: 目标可以量化, 有计划的, 数据支撑. A (Achievable) 可达成: 付出努力的情况下可以实现你的目标, 避免设立过高或过低的目标. R (Relevant) 相关性: 指目标与那些还有关联, 需要配合, 辅助你完成目标.<div class=read-more-link><a href=/posts/engineer-law/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/engineer-read/>工程师-阅读(二)</a></h1><time datetime=2021-01-12T09:40:24+0800 class=post-date>January 12, 2021</time><ul class=tags><li class=tag-工程师><a href=https://yezihack.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%B8%88>工程师</a></li></ul></div>技术书籍 推荐参考: &#171;豆瓣编程图书TOP10&#187;
程序员修炼之道(第2版) 豆瓣分:9.0
原英文名&#171;The Pragmatic Programmer&#187; 直译为: 务实的程序员, 即靠谱的程序员.
这是一本如同航海的指南般的书, 被一代代开发者奉为圭臬.
已经出版20年啦, 当之无愧的"道", 可惜在国内出现各种修炼之道相关的书籍, 内容干货少之又少, 实在汗颜.
深入理解计算机系统(第2版) 豆瓣分: 9.7
原英文名Computer Systems: A programmer&rsquo;s Perpective
工程师人人必读之书, 没有之一.
本书最大的优点是从程序员的视角详细阐述计算机系统的本质概念.
主要包括: 1. 信息的表示和处理 2. 程序的机器级表示 3. 处理器体系结构 4. 优化程序性能 5. 存储器层次结构 6. 链接 7. 异常控制流 8. 虚拟存储器 9. 系统级I/O 10. 网络编程 11. 并发编程
Tip: 书比较厚, 读之前做好心理准备, 打硬仗.
代码大全(第2版) 豆瓣分: 9.3
原英文名称&#171;Code Complete&#187; 完成代码, 是一种教你如何一步一步完成开发.
这本书覆盖了软件全过程, 从需求分析, 系统架构,设计到具体编码规范, 编码技巧, 整个项目的生命周期. 是一部软件构建的百科全书.
重构:改善即有代码的设计(第2版) 豆瓣分:9.<div class=read-more-link><a href=/posts/engineer-read/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/gof-interface-combination/>设计模式-接口组合(八)</a></h1><time datetime=2021-01-11T20:23:10+0800 class=post-date>January 11, 2021</time><ul class=tags><li class=tag-设计模式><a href=https://yezihack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F>设计模式</a></li><li class=tag-教程><a href=https://yezihack.github.io/tags/%E6%95%99%E7%A8%8B>教程</a></li></ul></div>有一种非常经典的设计原则: 组合优于继承, 多用组合少用继承
为什么少用继承 继承是面向对象的四大特性之一, 表示类之间的 is-a 关系. 支持多态特性, 可以解决代码复用问题.
如果继承层次过深, 过复杂, 会影响到代码的可维护性, 可读性.
如上面, 继承带来的后果就是代码变得复杂, 因为层次过深, 继承关系过于复杂, 影响到代码的可读性与可维护性.
组合的优势 可以利用组合(composition), 接口(interface), 委托(delegation) 三个技术手段解决继承的问题.(如上面的问题)
利用接口实现多态特性
利用组合和委托实现代码复用问题
通过组合, 接口, 委托三个技术手段完全可以替换掉继承.
Tip: 在项目中不用或少用继承关系, 特别是一些复杂的继承关系 .
什么时候使用继承还是组合 一个技术的出现, 一定是有他的用武之地, 并非一无是处.
当类之间的继承结构稳定, 继承层次比较浅(最多有两层继承关系), 我们可以大胆使用继承.
当类之间的继承结构不稳定, 复杂, 继承层次又深,我们尽量考虑使用组合来替代继承
哪些设计模式使用了继承?
装饰者模式(decorator pattern) 策略模式(strategy pattern) 组合模式(composite pattern) 哪些设计模式使用了组合?
模板模式(template pattern)</article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/gof-program-to-interface/>设计模式-接口编程(七)</a></h1><time datetime=2021-01-11T11:38:43+0800 class=post-date>January 11, 2021</time><ul class=tags><li class=tag-设计模式><a href=https://yezihack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F>设计模式</a></li><li class=tag-教程><a href=https://yezihack.github.io/tags/%E6%95%99%E7%A8%8B>教程</a></li></ul></div>何为"接口"编程 基于接口而非实现编程.
英文: Program to an interface, not an implementation
这条原则是一条比较抽象,泛化的设计思想.
接口的本质: 接口就是一组协议或者约定, 是功能提供者给使用者的一个"功能列表"
接口编程 这条原则能非常有效地提高代码质量.
接口编程是将接口与实现相分离, 封装不稳定的实现, 暴露稳定的接口.
上游系统面向接口而非实现编程, 不依赖不稳定的实现细节. 当实现发生变化的时候, 上游系统基于上不需要做改动, 以些来降低耦合性,提高扩展性.
在软件开发中, 最大的挑战之一就是需求的不断变化, 这也是考验代码设计的好坏的一个标准.
越抽象, 越顶层,越脱离具体某一实现的设计, 越能提高代码的灵活性, 越能应对未来的需求变化.
好的代码设计, 不仅能应对当下的需求, 而且在将来需求发生变化的时候,仍然能够在不破坏原有代码设计性况下奶灵活应对.
而抽象就是提高代码扩展性, 灵活性, 可维护性最有效的手段之一
接口编程要点 函数的命名不能暴露任何实现细节 封装具体的实现细节 为实现类定义抽象接口. Tip: 做开发的时候, 一定要有抽象意识, 封装意识, 接口意识. 在定义接口的时候, 不要暴露任何实现细节.
接口的定义只表明做什么, 而不是怎么做.
什么时候使用接口 任何事物都有两面, 一味使用接口编程会导致不必要的开发负担.具体要搞清楚我们为了解决什么问题.
如果业务场景中, 某个功能只有一种实现方式, 未来也不可能被其它实现方式替换,则我们没必要设计接口.也没必须基于接口编程.直接使用类即可.
如果业务场景中, 某个功能可能被两种以上, 不</article></div><hr><div class=footer><nav id=page-nav><a href=/page/7/ rel=prev class="extend prev">&#171; Previous</a>
<a href=/>1</a>
<a href=/page/2/>2</a>
<a href=/page/3/>3</a>
<a href=/page/4/>4</a>
<a href=/page/5/>5</a>
<a href=/page/6/>6</a>
<a href=/page/7/>7</a>
<span class="page-number current">8</span>
<a href=/page/9/>9</a>
<a href=/page/10/>10</a>
<a href=/page/11/>11</a>
<a href=/page/12/>12</a>
<a href=/page/13/>13</a>
<a href=/page/14/>14</a>
<a href=/page/15/>15</a>
<a href=/page/16/>16</a>
<a href=/page/17/>17</a>
<a href=/page/18/>18</a>
<a href=/page/19/>19</a>
<a href=/page/9/ rel=next class="extend next">Next &#187;</a></div></main></div></body></html>