<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><script defer language=javascript type=text/javascript src=/js/bundle.min.14549c76bbc96f0af1574b0259efd70e52908cd36fb4d14ed3d290a1b6479eae.js></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=/favicon.png><title itemprop=name>空树之空</title><meta property="og:title" content="空树之空"><meta name=twitter:title content="空树之空"><meta itemprop=name content="空树之空"><meta name=application-name content="空树之空"><meta property="og:site_name" content="空树之空"><meta name=description content="《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes、DevOps和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。"><meta itemprop=description content="《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes、DevOps和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。"><meta property="og:description" content="《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes、DevOps和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。"><meta name=twitter:description content="《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes、DevOps和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。"><base href=https://yezihack.github.io/><link rel=canonical href=https://yezihack.github.io/ itemprop=url><meta name=url content="https://yezihack.github.io/"><meta name=twitter:url content="https://yezihack.github.io/"><meta property="og:url" content="https://yezihack.github.io/"><meta property="og:updated_time" content="29011-29-06T1144:25:23+0800"><link rel=sitemap type=application/xml title=Sitemap href=https://yezihack.github.io/sitemap.xml><link href=https://yezihack.github.io/index.xml rel=alternate type=application/rss+xml title=空树之空><meta name=robots content="index,follow"><meta name=googlebot content="index,follow"><meta name=twitter:site content><meta name=twitter:creator content><meta property="fb:admins" content><meta name=apple-mobile-web-app-title content="空树之空"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta property="og:type" content="website"><meta name=author content><script defer type=application/ld+json>{"@context":"http://schema.org","@type":"Article","headline":"空树之空","author":{"@type":"Person","name":""},"datePublished":"2023-11-29","description":"","wordCount":"0","mainEntityOfPage":"True","dateModified":"2023-11-29","image":{"@type":"imageObject","url":""},"publisher":{"@type":"Organization","name":"空树之空","logo":{"@type":"imageObject","url":""}}}</script><meta name=generator content="Hugo 0.114.0"><link type=text/css rel=stylesheet href=/css/bundle.min.aa949ea27ee9836d60d6ea4c073fd0885f51948c7eea0247da6b1aff4bc25c44.css><style>body{--sidebar-bg-color:#202020;--sidebar-img-border-color:#515151;--sidebar-p-color:#909090;--sidebar-h1-color:#FFF;--sidebar-a-color:#FFF;--sidebar-socials-color:#FFF;--text-color:#222;--bkg-color:#FAF9F6;--post-title-color:#303030;--list-color:#5a5a5a;--link-color:#268bd2;--date-color:#515151;--table-border-color:#E5E5E5;--table-stripe-color:#F9F9F9;--code-color:#bf616a;--code-background-color:#E5E5E5;--moon-sun-color:#FFF;--moon-sun-background-color:#515151}body.dark-theme{--text-color:#eee;--bkg-color:#121212;--post-title-color:#DBE2E9;--list-color:#9d9d9d;--link-color:#268bd2;--date-color:#9a9a9a;--table-border-color:#515151;--table-stripe-color:#202020;--code-color:#ff7f7f;--code-background-color:#393D47}body{background-color:var(--bkg-color)}</style></head><body class=dark-theme><div class=wrapper><aside class=sidebar><div class="container sidebar-sticky"><div class=light-dark align=right><button class=btn-light-dark title="Toggle light/dark mode"><svg class="moon" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16"><path fill="currentcolor" d="M6 .278a.768.768.0 01.08.858 7.208 7.208.0 00-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527.0 1.04-.055 1.533-.16a.787.787.0 01.81.316.733.733.0 01-.031.893A8.349 8.349.0 018.344 16C3.734 16 0 12.286.0 7.71.0 4.266 2.114 1.312 5.124.06A.752.752.0 016 .278z"/></svg><svg class="sun" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16"><path fill="currentcolor" d="M8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 0zm0 13a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 13zm8-5a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2a.5.5.0 01.5.5zM3 8a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2A.5.5.0 013 8zm10.657-5.657a.5.5.0 010 .707l-1.414 1.415a.5.5.0 11-.707-.708l1.414-1.414a.5.5.0 01.707.0zm-9.193 9.193a.5.5.0 010 .707L3.05 13.657a.5.5.0 01-.707-.707l1.414-1.414a.5.5.0 01.707.0zm9.193 2.121a.5.5.0 01-.707.0l-1.414-1.414a.5.5.0 01.707-.707l1.414 1.414a.5.5.0 010 .707zM4.464 4.465a.5.5.0 01-.707.0L2.343 3.05a.5.5.0 11.707-.707l1.414 1.414a.5.5.0 010 .708z"/></svg></button></div><div class=sidebar-about><h1 class=brand><a href=https://yezihack.github.io/><img src=/images/head.jpg alt="brand image"></a>
<a href=https://yezihack.github.io/><h1>空树之空</h1></a></h1><p class=lead>《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes、DevOps和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。</p></div><nav><ul class=sidebar-nav><li class=heading><a href=/about/>About</a></li><li class=heading><a href=/posts/>Posts</a></li><li class=sub-heading>Recent</li><li class=bullet><a href=https://yezihack.github.io/posts/helm-command/>Helm 常用命令</a></li><li class=bullet><a href=https://yezihack.github.io/posts/helm-template/>Helm Chart 模板</a></li><li class=bullet><a href=https://yezihack.github.io/posts/helm-tutorial/>Helm 入门学习</a></li><li class=bullet><a href=https://yezihack.github.io/posts/vm-share-dir/>Vmware 虚拟机共享宿主机文件夹</a></li><li class=bullet><a href=https://yezihack.github.io/posts/haproxy-keepalived/>Haproxy + Keepalived 实现 k8s 集群高可用</a></li><li class=heading><a href=/tags/>Tags</a></li></ul></nav><a target=_blank class=social title="RSS Feed" href=https://yezihack.github.io//posts/index.xml><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1.2em" viewBox="0 0 1280 1280"><g transform="translate(0.000000,1280.000000) scale(0.100000,-0.100000)" fill="currentcolor"><path d="M2295 11929c-284-12-642-45-707-65-17-5-18-63-18-1039 0-569 4-1036 8-1039 5-3 74 6 153 19 510 86 1168 95 1789 25 1348-153 2602-677 3670-1531 385-308 820-744 1126-1129 842-1060 1362-2313 1514-3650 70-621 61-1279-25-1789-13-79-22-148-19-153 3-4 471-8 1039-8h1035l5 23c51 225 85 942 67 1419-23 605-77 1044-198 1617-294 14e2-927 2734-1823 3846-1043 1295-2364 2259-3909 2854-1158 447-2451 656-3707 6e2z"/><path d="M2255 7845c-269-25-620-81-667-106-17-9-18-55-18-899 0-706 3-890 13-890 6 0 66 18 132 41 130 44 288 79 467 105 154 21 577 30 749 15 1207-107 2267-823 2814-1902 166-327 268-637 330-1001 38-227 48-384 42-662-8-348-44-590-126-831-23-66-41-126-41-132 0-10 184-13 890-13 844 0 890 1 899 18 27 50 88 452 110 725 14 162 14 624 1 782-59 703-233 1323-545 1945-481 956-1313 1788-2270 2268-620 310-1239 483-1940 542-165 14-669 10-840-5z"/><path d="M2519 3815c-391-66-725-336-868-703-79-201-96-462-45-677 83-344 338-641 666-774 116-47 205-69 330-80 412-39 811 153 1040 5e2 193 292 240 648 128 981-135 403-492 699-914 757-1e2 14-241 12-337-4z"/></g></svg></a><p class=footnote><br>&copy; 2023 百里江山. All rights reserved.</p></div></aside><main class="content container"><div class=posts><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/tutorial-grpc-stream-simple/>Go 实践教程-gRPC-流实例(八)</a></h1><time datetime=2020-10-21T14:20:48+0800 class=post-date>October 21, 2020</time><ul class=tags><li class=tag-Go实践教程><a href=https://yezihack.github.io/tags/go%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B>Go实践教程</a></li><li class=tag-golang><a href=https://yezihack.github.io/tags/golang>golang</a></li><li class=tag-教程><a href=https://yezihack.github.io/tags/%E6%95%99%E7%A8%8B>教程</a></li><li class=tag-grpc入门><a href=https://yezihack.github.io/tags/grpc%E5%85%A5%E9%97%A8>grpc入门</a></li></ul></div>你将会学到
一个完整的gRPC流实例，包括单向流与双向流的操作 如何实现gRPC流服务端代码 如何实现gRPC流客户端代码 准备 新建一个文件夹 go-grpc-simple-stream 在go-grpc-simple文件夹下建立三个目录: client, proto,server 使用 go mod 管理代码 在 go-grpc-simple-stream 目录下执行 go mod init go-grpc-simple-stream 编写 proto 文件 在 go-grpc-simple-stream/proto 目录下新建 hello.proto 文件
syntax = "proto3"; package hello; service HelloService { // 定义一个服务端推送客户的单向流 rpc ServerToClient(StreamRequest) returns (stream StreamResponse){}; //　定义一个客户端推送服务端的单向流 rpc ClientToServer(stream StreamRequest) returns (StreamResponse){}; // 定义一个服务端与客户端的双向流 rpc AllStream(stream StreamRequest) returns (stream StreamResponse){}; } // stream 请求结构 message StreamRequest { string data = 1; } // stream 响应结构 message StreamResponse { string data = 1; } 生成 pb go 代码 在 go-grpc-simple-stream/proto 目录下新建 gen.<div class=read-more-link><a href=/posts/tutorial-grpc-stream-simple/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/tutorial-grpc-simple/>Go 实践教程-gRPC-简单实例(七)</a></h1><time datetime=2020-10-21T14:20:39+0800 class=post-date>October 21, 2020</time><ul class=tags><li class=tag-Go实践教程><a href=https://yezihack.github.io/tags/go%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B>Go实践教程</a></li><li class=tag-golang><a href=https://yezihack.github.io/tags/golang>golang</a></li><li class=tag-教程><a href=https://yezihack.github.io/tags/%E6%95%99%E7%A8%8B>教程</a></li><li class=tag-grpc入门><a href=https://yezihack.github.io/tags/grpc%E5%85%A5%E9%97%A8>grpc入门</a></li></ul></div>你将会学到
一个完整的gRPC实例 如何实现gRPC服务端代码 如何实现gRPC客户端代码 准备 新建一个文件夹 go-grpc-simple 在go-grpc-simple文件夹下建立三个目录: client, proto,server 使用 go mod 管理代码 在 go-grpc-simple 目录下执行 go mod init grpc-simple 编写 proto 文件 在 go-grpc-simple/proto 目录下新建 hello.proto 文件
// 选择 proto3 语法 syntax = "proto3"; // 定义一个包名 package hello; // 定义一个 service 服务，相当于 GO 接口定义 service HelloService { // 以 rpc 开头，定义未实现的方法名称。 必须要有一个请求 message 和响应 message // rpc, returns 都是关键字 rpc Hello(StringRequest) returns (StringResponse){}; } // message 相当于一个结构体，里面定义字段属性， 先类型后变量名，然后序列号。 // protoful 编码是通过成员的唯一编号来绑定对应的数据。 // 定义一个请求结构体 message StringRequest { string value = 1; } // 定义一个响应结构体 message StringResponse { string result = 1; } 生成 pb go 代码 在 go-grpc-simple/proto 目录下新建 gen.<div class=read-more-link><a href=/posts/tutorial-grpc-simple/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/tutorial-grpc-protobuf/>Go 实践教程-gRPC-Protobuf(六)</a></h1><time datetime=2020-10-21T14:20:32+0800 class=post-date>October 21, 2020</time><ul class=tags><li class=tag-Go实践教程><a href=https://yezihack.github.io/tags/go%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B>Go实践教程</a></li><li class=tag-golang><a href=https://yezihack.github.io/tags/golang>golang</a></li><li class=tag-教程><a href=https://yezihack.github.io/tags/%E6%95%99%E7%A8%8B>教程</a></li><li class=tag-grpc入门><a href=https://yezihack.github.io/tags/grpc%E5%85%A5%E9%97%A8>grpc入门</a></li></ul></div>Protobuf 是 Protobuf Buffers 的简称，它是 Google 公司开发的一种数据描述语言，并于2008年开源。
可用作为设计安全的跨语言 RPC 接口的基础工具。
目前 Protobuf 已经发展到第3版本，即 syntax = "proto3"; 你将会学到
如何编写 protobuf 文件 如何通过protoc工具生成 go 代码 编写 protobuf 文件 先定义语法版本 再定义package 定义一个 service 定义一组 request，response 的 message 创建 hello.proto 文件
第一行结尾需要写上分号; service 相当于定义接口， rpc 定义未实现的接口方法 message 相当于定义一个结构体，里面定义字段属性， 先类型后变量名，然后序列号。 每一行数据类型后需要写一个编号，从1开始，因为编码是通过成员的唯一编号来绑定对应的数据。 推荐使用请求message后加上Request关键字, 如StringRequest 推荐使用响应message后加上Response关键字，如StringResponse // 选择 proto3 语法 syntax = "proto3"; // 定义一个包名为 hello package hello; // 定义一个 service 服务名为 HelloService，相当于 GO 接口定义 service HelloService { // 以 rpc 开头，定义未实现的方法名称。 必须要有一个请求 message 和响应 message // rpc, returns 都是关键字 rpc Hello(StringRequest) returns (StringResponse){}; } // message 相当于一个结构体，里面定义字段属性， 先类型后变量名，然后序列号。 // protoful 编码是通过成员的唯一编号来绑定对应的数据。 // 定义一个请求结构体 message StringRequest { string value = 1; } // 定义一个响应结构体 message StringResponse { string result = 1; } 标量类型 以下只列出常用的类型对应关系。更多参考最下面的链接<div class=read-more-link><a href=/posts/tutorial-grpc-protobuf/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/tutorial-grpc-base/>Go 实践教程-gRPC-简介(五)</a></h1><time datetime=2020-10-21T14:18:34+0800 class=post-date>October 21, 2020</time><ul class=tags><li class=tag-Go实践教程><a href=https://yezihack.github.io/tags/go%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B>Go实践教程</a></li><li class=tag-golang><a href=https://yezihack.github.io/tags/golang>golang</a></li><li class=tag-教程><a href=https://yezihack.github.io/tags/%E6%95%99%E7%A8%8B>教程</a></li><li class=tag-grpc入门><a href=https://yezihack.github.io/tags/grpc%E5%85%A5%E9%97%A8>grpc入门</a></li></ul></div>什么是gRPC RPC 是远程过程调用 (Remote Procedure Call)的缩写。在 RPC 中，客户端应用程序可以直接调用不同机器上的服务器应用程序上的方法，就像它是本地对象一样，使您可以更轻松地创建分布式应用程序和服务。
gRPC 是 Google 开源的基于 Protobuf 和 Http2.0 协议的通信框架，底层由netty提供。
是一款语言中立、平台中立、开源的远程过程调用(RPC)系统。
特点 基于HTTP/2协议实现，实现多路复用，双向流等特点。 基于 Protobuf 协议，支持多种语言。 参考 gRPC 官方文档中文版
推荐学习 gRPC入门 简介 gRPC入门 Protobuf gRPC入门 搭建完整gRPC gRPC入门 实现双向流</article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/book/>书籍 BOOK</a></h1><time datetime=2020-10-19T17:33:12+0800 class=post-date>October 19, 2020</time><ul class=tags><li class=tag-分享><a href=https://yezihack.github.io/tags/%E5%88%86%E4%BA%AB>分享</a></li><li class=tag-book><a href=https://yezihack.github.io/tags/book>book</a></li></ul></div>拒绝某度盘，支持蓝凑盘, 欢迎留言，提供资源。只提供最优质的资源。
序列 书名 备注 1 高性能MySQL（第3版） 带目录 2 设计模式之禅 带目录，第1版本</article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/fix-rsyslog/>rsyslog 占用内存过高</a></h1><time datetime=2020-10-16T10:38:58+0800 class=post-date>October 16, 2020</time><ul class=tags><li class=tag-linux><a href=https://yezihack.github.io/tags/linux>linux</a></li><li class=tag-优化><a href=https://yezihack.github.io/tags/%E4%BC%98%E5%8C%96>优化</a></li></ul></div>排查问题 使用top 再按大写M， 对内存采用降序显示，一目了然看到谁占用内存最高。
定位到rsyslogd进程占用内存25.7%，非常可怕，需要急需解决掉它。
什么是rsyslog: 系统提供的多线性日志系统，参考: https://www.rsyslog.com/
解决问题 rsyslogd是它的守护进程，可以通过systemctl status rsyslog 查看运行状态
红色显示错误信息。
使用journalctl --verify 检查系统日志卷文件损坏情况
如果检查出来有红色的文件，则直接删除即可。
删除/var/lib/rsyslog/imjournal.state 文件
重启rsyslogd进程， systemctl restart rsyslog
然后使用 top 查看，内存占用率是否没有啦。
避免再次发生 修改/etc/rsyslog.conf 文件
最后行添加2行代码
$imjournalRatelimitInterval 0 $imjournalRatelimitBurst 0 重启服务:systemctl restart rsyslog
关闭 journal 压缩配置
vim /etc/systemd/journald.conf # 找到 #Compress=yes 修改成 no Compress=no # 重启服务 systemctl restart systemd-journald</article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/docker-install/>Docker笔记(二) 安装</a></h1><time datetime=2020-10-15T17:12:16+0800 class=post-date>October 15, 2020</time><ul class=tags><li class=tag-docker><a href=https://yezihack.github.io/tags/docker>docker</a></li><li class=tag-docker教程><a href=https://yezihack.github.io/tags/docker%E6%95%99%E7%A8%8B>docker教程</a></li><li class=tag-教程><a href=https://yezihack.github.io/tags/%E6%95%99%E7%A8%8B>教程</a></li></ul></div>适合于 CentOS 系统
docker 一键安装 curl -sSL https://cdn.jsdelivr.net/gh/yezihack/assets/sh/docker-install.sh |sudo sh #!/bin/bash ################ # CentOS 一键安装 # From: sgfoot.com ################# # 卸载旧版本 sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine # 设置仓库 sudo yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 # 使用阿里源地址 sudo yum-config-manager \ --add-repo \ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 安装 Docker Engine sudo yum install docker-ce docker-ce-cli containerd.io -y # 启动 systemctl start docker # 测试一下 sudo docker run hello-world echo "安装完毕" docker-compose 安装 docker-compose 是负责 docker 编排使用的<div class=read-more-link><a href=/posts/docker-install/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/onekey-node_export/>node_export 一键安装</a></h1><time datetime=2020-10-15T16:49:55+0800 class=post-date>October 15, 2020</time><ul class=tags><li class=tag-一键安装><a href=https://yezihack.github.io/tags/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85>一键安装</a></li><li class=tag-shell><a href=https://yezihack.github.io/tags/shell>shell</a></li><li class=tag-脚本><a href=https://yezihack.github.io/tags/%E8%84%9A%E6%9C%AC>脚本</a></li></ul></div>仅适合用 CentOS 7
node_export 安装 linux 服务器信息等资源收集安装包
一键安装
curl -sSL http://s1.sgfoot.com/sh/node_exporter.sh |sh 验证 netstat -nplt |grep node_exporter 配置nginx安全访问 如果涉及到外网访问则需要配置密码访问
参考：nginx 添加权限验证
htpasswd -bc /etc/nginx/htpasswd.users sgfoot sgfoot.pass # sgfoot 是帐号名 # sgfoot.pass 是密码 nginx 的vhost配置 node_exporter.conf
server { listen 80; server_name node_exporter.io; location / { auth_basic "Prometheus"; auth_basic_user_file /etc/nginx/htpasswd.users;# 验证文件 proxy_pass http://127.0.0.1:9100; } } 添加 prometheus 节点 配置 host
vim /etc/hosts 127.0.0.1 mysqld_exporter.io vim /data/local/prometheus/prometheus.yml 在 node_exporter.targets 添加 host:port
scrape_configs: - job_name: 'node_exporter' static_configs: - targets: ['sgfoot.<div class=read-more-link><a href=/posts/onekey-node_export/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/docker-theory/>Docker笔记(一) 原理</a></h1><time datetime=2020-10-14T18:11:18+0800 class=post-date>October 14, 2020</time><ul class=tags><li class=tag-docker><a href=https://yezihack.github.io/tags/docker>docker</a></li><li class=tag-docker教程><a href=https://yezihack.github.io/tags/docker%E6%95%99%E7%A8%8B>docker教程</a></li><li class=tag-教程><a href=https://yezihack.github.io/tags/%E6%95%99%E7%A8%8B>教程</a></li></ul></div>什么是docker Docker 是 dotCloud 公司开源的一款产品，2013年开源(基于golang开发)。
Docker 英文意思是“搬运工", 是一种容器化技术，将您的运行软件封到一个沙盒里，随意搬运的应用容器引擎。
容器技术是所有云应用的基石，也把互联网升到到下一代。足以说明 docker 的强大之处。
Google 自2004年开始使用容器技术，对Docker的贡献之大，开源了Cgroup和Imctfy项目，还开源了容器管理系统 Kubernetes.
向开源致敬！
Docker 架构 采用 c/s 模式体系架构， Docker 客户端与 Docker Daemon 守护进程通信。
Docker Daemon: 是Docker服务端的守护进程， 用来监听 Docker API 的请求和管理 Docker 对象，比如镜像、容器、网络和 Volume。 Docker Client: docker client 是我们和 Docker 进行交互的最主要的方式方法 Docker Registry：用来存储 Docker 镜像的仓库 Images：镜像，镜像是一个只读模板 Containers：容器，容器是一个镜像的可运行的实例,容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间 底层技术支持：Namespaces（做隔离）、CGroups（做资源限制）、UnionFS（镜像和容器的分层） Docker 核心技术 Docker 的基础是 Linux 容器(LXC) 等技术
三大底层技术实现 Docker 的关键技术
Namespaces 解决了进程，网络及文件系统的隔离 命名空间（namespaces）是 Linux 为我们提供的用于分离进程树、网络接口、挂载点以及进程间通信等资源的方法 CGroups 解决了CPU,内存等资源隔离 Namespaces 并不能够为我们提供物理资源上的隔离。比如CPU，内存等。这样会导致多个Docker抢占物理资源。 Control Groups（简称 CGroups）就是能够隔离宿主机器上的物理资源，例如 CPU、内存、磁盘 I/O 和网络带宽。 UnionFS 解决了镜像隔离 Union File System，联合文件系统 将多个不同位置的目录联合挂载到同一个目录，将相同的部分合并</article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/tutorial-golang-base/>Go 实践教程-基本语法(四)</a></h1><time datetime=2020-09-29T17:29:55+0800 class=post-date>September 29, 2020</time><ul class=tags><li class=tag-Go实践教程><a href=https://yezihack.github.io/tags/go%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B>Go实践教程</a></li><li class=tag-golang><a href=https://yezihack.github.io/tags/golang>golang</a></li><li class=tag-教程><a href=https://yezihack.github.io/tags/%E6%95%99%E7%A8%8B>教程</a></li></ul></div>本篇主要介绍，基本数据类型、控制语句和数据结构及函数、方法、接口等知识。为后面学习打下基础，有个基本的认识。也为您将来进阶做准备。
基础语法 之前我们在Go 实践教程-工具及运行(三)写过一个“hello world”程序，讲解了三个概念：package,import,main
注释 写代码时必不可少需要写一些代码注释，方便以后回过头来看程序。Go里面提供两种方法注释
// 单行注释 （注意 //之后需要一个空格，之于为什么，go doc 方便自动生成文档抓取注释） /* 多行注释，在这里面都属于被注释的内容 */ 标识符 标识符用来命名变量，类型等程序实体。允许由大小写字母(a-z|A-Z)和数据(0~9)及下划线(_)组成，但第一个字符必须由字母和下划线组成
a := 10 // ok _a := 22 // ok case := "abc"// 无效变量 error 9a := 10 // 无效变量 error 变量命名 Go 语言的变量命名比较独特，如果你熟悉其它语言你会不习惯的。
先变量名 后跟类型名称
全局变量
必须有 var 关键字
import main var num int func main() { } // 优雅的方法,适合多个变量， 也适用于import 里 var ( num int age int name string ) // 等价于 var num int var age int var name string 函数内的局部变量<div class=read-more-link><a href=/posts/tutorial-golang-base/>Read More…</a></div></article></div><hr><div class=footer><nav id=page-nav><a href=/page/10/ rel=prev class="extend prev">&#171; Previous</a>
<a href=/>1</a>
<a href=/page/2/>2</a>
<a href=/page/3/>3</a>
<a href=/page/4/>4</a>
<a href=/page/5/>5</a>
<a href=/page/6/>6</a>
<a href=/page/7/>7</a>
<a href=/page/8/>8</a>
<a href=/page/9/>9</a>
<a href=/page/10/>10</a>
<span class="page-number current">11</span>
<a href=/page/12/>12</a>
<a href=/page/13/>13</a>
<a href=/page/14/>14</a>
<a href=/page/15/>15</a>
<a href=/page/16/>16</a>
<a href=/page/17/>17</a>
<a href=/page/18/>18</a>
<a href=/page/19/>19</a>
<a href=/page/12/ rel=next class="extend next">Next &#187;</a></div></main></div></body></html>