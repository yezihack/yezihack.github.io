<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><script defer language=javascript type=text/javascript src=/js/bundle.min.14549c76bbc96f0af1574b0259efd70e52908cd36fb4d14ed3d290a1b6479eae.js></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=/favicon.png><title itemprop=name>空树之空</title><meta property="og:title" content="空树之空"><meta name=twitter:title content="空树之空"><meta itemprop=name content="空树之空"><meta name=application-name content="空树之空"><meta property="og:site_name" content="空树之空"><meta name=description content="《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes（K8s）、DevOps、GitOps、运维和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。By <a href='https://github.com/yezihack' target='_blank'>@yezihack</a>"><meta itemprop=description content="《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes（K8s）、DevOps、GitOps、运维和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。By <a href='https://github.com/yezihack' target='_blank'>@yezihack</a>"><meta property="og:description" content="《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes（K8s）、DevOps、GitOps、运维和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。By <a href='https://github.com/yezihack' target='_blank'>@yezihack</a>"><meta name=twitter:description content="《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes（K8s）、DevOps、GitOps、运维和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。By <a href='https://github.com/yezihack' target='_blank'>@yezihack</a>"><base href=https://yezihack.github.io/><link rel=canonical href=https://yezihack.github.io/ itemprop=url><meta name=url content="https://yezihack.github.io/"><meta name=twitter:url content="https://yezihack.github.io/"><meta property="og:url" content="https://yezihack.github.io/"><meta property="og:updated_time" content="5007-05-11T741:00:23+0800"><link rel=sitemap type=application/xml title=Sitemap href=https://yezihack.github.io/sitemap.xml><link href=https://yezihack.github.io/index.xml rel=alternate type=application/rss+xml title=空树之空><meta name=robots content="index,follow"><meta name=googlebot content="index,follow"><meta name=twitter:site content><meta name=twitter:creator content><meta property="fb:admins" content><meta name=apple-mobile-web-app-title content="空树之空"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta property="og:type" content="website"><meta name=author content><script defer type=application/ld+json>{"@context":"http://schema.org","@type":"Article","headline":"空树之空","author":{"@type":"Person","name":""},"datePublished":"2023-07-05","description":"","wordCount":"0","mainEntityOfPage":"True","dateModified":"2023-07-05","image":{"@type":"imageObject","url":""},"publisher":{"@type":"Organization","name":"空树之空","logo":{"@type":"imageObject","url":""}}}</script><meta name=generator content="Hugo 0.114.0"><link type=text/css rel=stylesheet href=/css/bundle.min.aa949ea27ee9836d60d6ea4c073fd0885f51948c7eea0247da6b1aff4bc25c44.css><style>body{--sidebar-bg-color:#202020;--sidebar-img-border-color:#515151;--sidebar-p-color:#909090;--sidebar-h1-color:#FFF;--sidebar-a-color:#FFF;--sidebar-socials-color:#FFF;--text-color:#222;--bkg-color:#FAF9F6;--post-title-color:#303030;--list-color:#5a5a5a;--link-color:#268bd2;--date-color:#515151;--table-border-color:#E5E5E5;--table-stripe-color:#F9F9F9;--code-color:#bf616a;--code-background-color:#E5E5E5;--moon-sun-color:#FFF;--moon-sun-background-color:#515151}body.dark-theme{--text-color:#eee;--bkg-color:#121212;--post-title-color:#DBE2E9;--list-color:#9d9d9d;--link-color:#268bd2;--date-color:#9a9a9a;--table-border-color:#515151;--table-stripe-color:#202020;--code-color:#ff7f7f;--code-background-color:#393D47}body{background-color:var(--bkg-color)}</style></head><body class=dark-theme><div class=wrapper><aside class=sidebar><div class="container sidebar-sticky"><div class=light-dark align=right><button class=btn-light-dark title="Toggle light/dark mode"><svg class="moon" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16"><path fill="currentcolor" d="M6 .278a.768.768.0 01.08.858 7.208 7.208.0 00-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527.0 1.04-.055 1.533-.16a.787.787.0 01.81.316.733.733.0 01-.031.893A8.349 8.349.0 018.344 16C3.734 16 0 12.286.0 7.71.0 4.266 2.114 1.312 5.124.06A.752.752.0 016 .278z"/></svg><svg class="sun" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16"><path fill="currentcolor" d="M8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 0zm0 13a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 13zm8-5a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2a.5.5.0 01.5.5zM3 8a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2A.5.5.0 013 8zm10.657-5.657a.5.5.0 010 .707l-1.414 1.415a.5.5.0 11-.707-.708l1.414-1.414a.5.5.0 01.707.0zm-9.193 9.193a.5.5.0 010 .707L3.05 13.657a.5.5.0 01-.707-.707l1.414-1.414a.5.5.0 01.707.0zm9.193 2.121a.5.5.0 01-.707.0l-1.414-1.414a.5.5.0 01.707-.707l1.414 1.414a.5.5.0 010 .707zM4.464 4.465a.5.5.0 01-.707.0L2.343 3.05a.5.5.0 11.707-.707l1.414 1.414a.5.5.0 010 .708z"/></svg></button></div><div class=sidebar-about><h1 class=brand><a href=https://yezihack.github.io/><img src=/images/brand_image.jpg alt="brand image"></a>
<a href=https://yezihack.github.io/><h1>空树之空</h1></a></h1><p class=lead>《空樹之空》博客是一个技术导向的平台，聚焦于Kubernetes（K8s）、DevOps、GitOps、运维和Linux等领域。通过简洁而优美的文字，我们提供对这些技术主题的深入探索和实用的指南。By <a href=https://github.com/yezihack target=_blank>@yezihack</a></p></div><nav><ul class=sidebar-nav><li class=heading><a href=/about/>About</a></li><li class=heading><a href=/posts/>Posts</a></li><li class=sub-heading>Recent</li><li class=bullet><a href=https://yezihack.github.io/posts/haproxy-keepalived/>Haproxy + Keepalived 实现 k8s 集群高可用</a></li><li class=bullet><a href=https://yezihack.github.io/posts/istio-ratelimit/>Istio 限流实现</a></li><li class=bullet><a href=https://yezihack.github.io/posts/istio-install/>Istio 安装</a></li><li class=bullet><a href=https://yezihack.github.io/posts/etcd-v3.2/>云运维笔记(10) Etcd V3.2 集群二进制搭建</a></li><li class=bullet><a href=https://yezihack.github.io/posts/etcd-v3.4/>云运维笔记(11) Etcd V3.4 集群二进制搭建</a></li><li class=heading><a href=/tags/>Tags</a></li></ul></nav><a target=_blank class=social title=GitHub href=https://github.com/yezihack><svg xmlns="http://www.w3.org/2000/svg" width="1.2em" height="1.2em" viewBox="-2 -2 24 24"><path fill="currentcolor" d="M18.88 1.099C18.147.366 17.265.0 16.233.0H3.746C2.714.0 1.832.366 1.099 1.099.366 1.832.0 2.714.0 3.746v12.487c0 1.032.366 1.914 1.099 2.647.733.733 1.615 1.099 2.647 1.099H6.66c.19.0.333-.007.429-.02a.504.504.0 00.286-.169c.095-.1.143-.245.143-.435l-.007-.885c-.004-.564-.006-1.01-.006-1.34l-.3.052c-.19.035-.43.05-.721.046a5.555 5.555.0 01-.904-.091 2.026 2.026.0 01-.872-.39 1.651 1.651.0 01-.572-.8l-.13-.3a3.25 3.25.0 00-.41-.663c-.186-.243-.375-.407-.566-.494l-.09-.065a.956.956.0 01-.17-.156.723.723.0 01-.117-.182c-.026-.061-.004-.111.065-.15.07-.04.195-.059.378-.059l.26.04c.173.034.388.138.643.311a2.1 2.1.0 01.631.677c.2.355.44.626.722.813.282.186.566.28.852.28.286.0.533-.022.742-.065a2.59 2.59.0 00.585-.196c.078-.58.29-1.028.637-1.34a8.907 8.907.0 01-1.333-.234 5.314 5.314.0 01-1.223-.507 3.5 3.5.0 01-1.047-.872c-.277-.347-.505-.802-.683-1.365-.177-.564-.266-1.215-.266-1.952.0-1.049.342-1.942 1.027-2.68-.32-.788-.29-1.673.091-2.652.252-.079.625-.02 1.119.175.494.195.856.362 1.086.5.23.14.414.257.553.352a9.233 9.233.0 012.497-.338c.859.0 1.691.113 2.498.338l.494-.312a6.997 6.997.0 011.197-.572c.46-.174.81-.221 1.054-.143.39.98.424 1.864.103 2.653.685.737 1.028 1.63 1.028 2.68.0.737-.089 1.39-.267 1.957-.177.568-.407 1.023-.689 1.366a3.65 3.65.0 01-1.053.865c-.42.234-.828.403-1.223.507a8.9 8.9.0 01-1.333.235c.45.39.676 1.005.676 1.846v3.11c0 .147.021.266.065.357a.36.36.0 00.208.189c.096.034.18.056.254.064.074.01.18.013.318.013h2.914c1.032.0 1.914-.366 2.647-1.099.732-.732 1.099-1.615 1.099-2.647V3.746c0-1.032-.367-1.914-1.1-2.647z"/></svg></a><a target=_blank class=social title="RSS Feed" href=https://yezihack.github.io//posts/index.xml><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1.2em" viewBox="0 0 1280 1280"><g transform="translate(0.000000,1280.000000) scale(0.100000,-0.100000)" fill="currentcolor"><path d="M2295 11929c-284-12-642-45-707-65-17-5-18-63-18-1039 0-569 4-1036 8-1039 5-3 74 6 153 19 510 86 1168 95 1789 25 1348-153 2602-677 3670-1531 385-308 820-744 1126-1129 842-1060 1362-2313 1514-3650 70-621 61-1279-25-1789-13-79-22-148-19-153 3-4 471-8 1039-8h1035l5 23c51 225 85 942 67 1419-23 605-77 1044-198 1617-294 14e2-927 2734-1823 3846-1043 1295-2364 2259-3909 2854-1158 447-2451 656-3707 6e2z"/><path d="M2255 7845c-269-25-620-81-667-106-17-9-18-55-18-899 0-706 3-890 13-890 6 0 66 18 132 41 130 44 288 79 467 105 154 21 577 30 749 15 1207-107 2267-823 2814-1902 166-327 268-637 330-1001 38-227 48-384 42-662-8-348-44-590-126-831-23-66-41-126-41-132 0-10 184-13 890-13 844 0 890 1 899 18 27 50 88 452 110 725 14 162 14 624 1 782-59 703-233 1323-545 1945-481 956-1313 1788-2270 2268-620 310-1239 483-1940 542-165 14-669 10-840-5z"/><path d="M2519 3815c-391-66-725-336-868-703-79-201-96-462-45-677 83-344 338-641 666-774 116-47 205-69 330-80 412-39 811 153 1040 5e2 193 292 240 648 128 981-135 403-492 699-914 757-1e2 14-241 12-337-4z"/></g></svg></a><a target=_blank class=social title=Email href=mailto://freeit@126.com><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1.2em" viewBox="0 0 485.211 485.211"><path fill="currentcolor" d="M301.393 241.631 464.866 424.56H20.332l163.474-182.928 58.801 51.443 58.786-51.444zM462.174 60.651H23.027l219.579 192.142L462.174 60.651zM324.225 221.67l160.986 180.151V80.792L324.225 221.67zM0 80.792v321.029L160.972 221.64.0 80.792z"/></svg></a><p class=footnote>powered by <a target=_blank href=https://gohugo.io>Hugo</a> | themed with <a target=_blank href=https://github.com/lukeorth/poison>poison</a><br>&copy; 2023 空树之空. All rights reserved.</p></div></aside><main class="content container"><div class=posts><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/docker-base/>Docker笔记(三) 基础知识</a></h1><time datetime=2020-11-04T15:20:11+0800 class=post-date>November 4, 2020</time><ul class=tags><li class=tag-docker><a href=https://yezihack.github.io/tags/docker>docker</a></li><li class=tag-docker教程><a href=https://yezihack.github.io/tags/docker%E6%95%99%E7%A8%8B>docker教程</a></li><li class=tag-教程><a href=https://yezihack.github.io/tags/%E6%95%99%E7%A8%8B>教程</a></li></ul></div>.1. Docker 三大基础组件 .2. Docker 指令 Docker 三大基础组件 三个重要的概念
仓库(Repository) 镜像(Image) 容器(Container) 实例命令:　docker run --name db --env MYSQL_ROOT_PASSWORD=sgfoot.com -d mariadb
先在本机查找有没有 mariadb 镜像, 如果没有,就到 docker 的仓库查找 mariadb 镜像, 然后下载到本机 基本 mariadb 镜像创建容器 db, 提供 mysql 服务 然后通过 docker ps 查看正在运行的容器. Docker 指令 基本命令格式如下: docker + command(如run, ps) + 一系列参数(args...) 如: docker run --name db --env MYSQL_ROOT_PASSWORD=sgfoot.com -d mariadb
命令帮助 docker command --help
如: docker run --help
命令分四大类 系统资源设置和全局信息获取: docker info, docker system df Docker 仓库查询, 下载操作:docker search, docker pull Docker 镜像查询,创建,删除操作: docker images, docker build, docker rmi Docker 容器查询,创建,开启,停止,删除,详情操作:docker ps, docker run, docker start, docker stop, docker rm, docker inspect Docker 调试: docker logs(日志), docker stats(运行状态) 其它: 删除所有停止运行的容器 docker rm $(docker ps -a -q) (危险操作)</article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/docker-command/>Docker笔记(七) 命令</a></h1><time datetime=2020-11-03T19:49:09+0800 class=post-date>November 3, 2020</time><ul class=tags><li class=tag-docker><a href=https://yezihack.github.io/tags/docker>docker</a></li><li class=tag-docker教程><a href=https://yezihack.github.io/tags/docker%E6%95%99%E7%A8%8B>docker教程</a></li><li class=tag-教程><a href=https://yezihack.github.io/tags/%E6%95%99%E7%A8%8B>教程</a></li></ul></div>前面教程介绍过 docker 是 c/s 模式, 通过 client 命令 与 server 端进行交互, docker 有着强大的命令系统, 我们需要系统学习下.
基础的命令 查看版本 docker version
查看 docker 信息 会显示多少镜像,容器, 运行中,暂停中, 停止的容器数量, cpu, memory, system等信息
docker info
容器操作 下载仓库 docker pull centos
运行容器 docker run -it centos /bin/bash
docker run -it
-i 交互式操作 -t 终端 centos 镜像 /bin/bash 交互使用/bin/bash模式 查看容器 docker ps 查看正在运行的容器
docker ps -a 查看所有容器,包括运行中,停止和暂停的容器
启动指定ID的容器 docker start ID 支持3位数操作.
停止容器 docker stop ID
暂停容器 docker pause ID<div class=read-more-link><a href=/posts/docker-command/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/git-tag/>Git Tag 常用命令</a></h1><time datetime=2020-10-30T16:43:01+0800 class=post-date>October 30, 2020</time><ul class=tags><li class=tag-git><a href=https://yezihack.github.io/tags/git>git</a></li></ul></div>git tag 是给当前仓库设置一个快照,常用于设置版本号, 你有必须知道一下.
查看 git tag # 查看当前项目的tag git show v1.0.0 # 查看某 tag 的详情 创建 git tag v1.0.0 # 给当前项目版本打上 v1.0.0 版本号 # 给指定的提交版本号打上 tag git log --pretty=oneline --abbrev-commit # 查看所有短ID 312bda6 (HEAD -> master) # 给日志 312bda6 打上 tag git tag v1.0.3 312bda6 # 给标签写上注释 git tag -a v1.2.0 -m "tag notes" 提交 git push origin v1.0.0 # 将 v1.0.0 推送到远程 git push --tags # 推送本地的所有的 Tag 删除 git tag -d v1.<div class=read-more-link><a href=/posts/git-tag/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/go-mod-private/>Go Mod 引用私有仓库</a></h1><time datetime=2020-10-30T16:01:25+0800 class=post-date>October 30, 2020</time><ul class=tags><li class=tag-go><a href=https://yezihack.github.io/tags/go>go</a></li><li class=tag-golang><a href=https://yezihack.github.io/tags/golang>golang</a></li><li class=tag-error><a href=https://yezihack.github.io/tags/error>error</a></li></ul></div>在做 go 开发, 如果是使用 go1.11 版本, 相信大家都会使用到 go mod 做为依赖管理, 因为 go mod 可以设置代理,国外的包,轻松下载. 但是在某一天你使用公司自建的 gitlab ,需要引用 gitlab 上面的依赖包,就需要做一些设置才会正常 go mod tidy,否则会出现无法引用的问题. 本文介绍一下如何操作.
适用于 window, linux 环境, 本人没 macOSX
你将学到:
如何设置 go mod 代理 如何设置 go env GOPRIVATE 变量 如何在代码里引用自建的 gitlab 依赖代码 设置 go mod 代理 linux, window 设置
go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.io,direct 实践 假定私有 gitlab 仓库地址为: http://mygit.sgfoot.com/ (注意只支持http, 不支持https)
创建一个 gitlab 依赖代码 仓库地址HTTP: http://mygit.sgfoot.com/common.git 仓库地址SSH: git@mygit.<div class=read-more-link><a href=/posts/go-mod-private/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/tools/>万能工具箱</a></h1><time datetime=2020-10-29T17:11:51+0800 class=post-date>October 29, 2020</time><ul class=tags><li class=tag-工具><a href=https://yezihack.github.io/tags/%E5%B7%A5%E5%85%B7>工具</a></li><li class=tag-tool><a href=https://yezihack.github.io/tags/tool>tool</a></li></ul></div>脚本工具 名称 安装/下载 备注 检查 shell 工具 yum -y install ShellCheck 下载 能检查sh语法</article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/onekey-mysqld-exporter/>mysqld_export 一键安装</a></h1><time datetime=2020-10-22T14:32:37+0800 class=post-date>October 22, 2020</time><ul class=tags><li class=tag-一键安装><a href=https://yezihack.github.io/tags/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85>一键安装</a></li><li class=tag-shell><a href=https://yezihack.github.io/tags/shell>shell</a></li><li class=tag-脚本><a href=https://yezihack.github.io/tags/%E8%84%9A%E6%9C%AC>脚本</a></li></ul></div>仅适用 CentOS 7
mysqld_export 安装 prometheus 监听 mysql 服务
一键安装
curl -sSL http://s1.sgfoot.com/sh/mysql_exporter.sh | sudo bash 验证 # 验证进程是否启动 netstat -nplt |grep mysqld_exporter # 验证是否可以获取 metrics curl http://localhost:9104/metrics 配置nginx安全访问 如果涉及到外网访问则需要配置密码访问
参考：nginx 添加权限验证
htpasswd -bc /etc/nginx/htpasswd.users sgfoot sgfoot.pass # sgfoot 是帐号名 # sgfoot.pass 是密码 nginx 的vhost配置 mysqld_exporter.conf
server { listen 80; server_name mysqld_exporter.io; location / { auth_basic "Prometheus"; auth_basic_user_file /etc/nginx/htpasswd.users;# 验证文件 proxy_pass http://127.0.0.1:9104; } } 添加 prometheus 节点 配置 host<div class=read-more-link><a href=/posts/onekey-mysqld-exporter/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/tutorial-grpc-stream-simple/>Go 实践教程-gRPC-流实例(八)</a></h1><time datetime=2020-10-21T14:20:48+0800 class=post-date>October 21, 2020</time><ul class=tags><li class=tag-Go实践教程><a href=https://yezihack.github.io/tags/go%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B>Go实践教程</a></li><li class=tag-golang><a href=https://yezihack.github.io/tags/golang>golang</a></li><li class=tag-教程><a href=https://yezihack.github.io/tags/%E6%95%99%E7%A8%8B>教程</a></li><li class=tag-grpc入门><a href=https://yezihack.github.io/tags/grpc%E5%85%A5%E9%97%A8>grpc入门</a></li></ul></div>你将会学到
一个完整的gRPC流实例，包括单向流与双向流的操作 如何实现gRPC流服务端代码 如何实现gRPC流客户端代码 准备 新建一个文件夹 go-grpc-simple-stream 在go-grpc-simple文件夹下建立三个目录: client, proto,server 使用 go mod 管理代码 在 go-grpc-simple-stream 目录下执行 go mod init go-grpc-simple-stream 编写 proto 文件 在 go-grpc-simple-stream/proto 目录下新建 hello.proto 文件
syntax = "proto3"; package hello; service HelloService { // 定义一个服务端推送客户的单向流 rpc ServerToClient(StreamRequest) returns (stream StreamResponse){}; //　定义一个客户端推送服务端的单向流 rpc ClientToServer(stream StreamRequest) returns (StreamResponse){}; // 定义一个服务端与客户端的双向流 rpc AllStream(stream StreamRequest) returns (stream StreamResponse){}; } // stream 请求结构 message StreamRequest { string data = 1; } // stream 响应结构 message StreamResponse { string data = 1; } 生成 pb go 代码 在 go-grpc-simple-stream/proto 目录下新建 gen.<div class=read-more-link><a href=/posts/tutorial-grpc-stream-simple/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/tutorial-grpc-simple/>Go 实践教程-gRPC-简单实例(七)</a></h1><time datetime=2020-10-21T14:20:39+0800 class=post-date>October 21, 2020</time><ul class=tags><li class=tag-Go实践教程><a href=https://yezihack.github.io/tags/go%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B>Go实践教程</a></li><li class=tag-golang><a href=https://yezihack.github.io/tags/golang>golang</a></li><li class=tag-教程><a href=https://yezihack.github.io/tags/%E6%95%99%E7%A8%8B>教程</a></li><li class=tag-grpc入门><a href=https://yezihack.github.io/tags/grpc%E5%85%A5%E9%97%A8>grpc入门</a></li></ul></div>你将会学到
一个完整的gRPC实例 如何实现gRPC服务端代码 如何实现gRPC客户端代码 准备 新建一个文件夹 go-grpc-simple 在go-grpc-simple文件夹下建立三个目录: client, proto,server 使用 go mod 管理代码 在 go-grpc-simple 目录下执行 go mod init grpc-simple 编写 proto 文件 在 go-grpc-simple/proto 目录下新建 hello.proto 文件
// 选择 proto3 语法 syntax = "proto3"; // 定义一个包名 package hello; // 定义一个 service 服务，相当于 GO 接口定义 service HelloService { // 以 rpc 开头，定义未实现的方法名称。 必须要有一个请求 message 和响应 message // rpc, returns 都是关键字 rpc Hello(StringRequest) returns (StringResponse){}; } // message 相当于一个结构体，里面定义字段属性， 先类型后变量名，然后序列号。 // protoful 编码是通过成员的唯一编号来绑定对应的数据。 // 定义一个请求结构体 message StringRequest { string value = 1; } // 定义一个响应结构体 message StringResponse { string result = 1; } 生成 pb go 代码 在 go-grpc-simple/proto 目录下新建 gen.<div class=read-more-link><a href=/posts/tutorial-grpc-simple/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/tutorial-grpc-protobuf/>Go 实践教程-gRPC-Protobuf(六)</a></h1><time datetime=2020-10-21T14:20:32+0800 class=post-date>October 21, 2020</time><ul class=tags><li class=tag-Go实践教程><a href=https://yezihack.github.io/tags/go%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B>Go实践教程</a></li><li class=tag-golang><a href=https://yezihack.github.io/tags/golang>golang</a></li><li class=tag-教程><a href=https://yezihack.github.io/tags/%E6%95%99%E7%A8%8B>教程</a></li><li class=tag-grpc入门><a href=https://yezihack.github.io/tags/grpc%E5%85%A5%E9%97%A8>grpc入门</a></li></ul></div>Protobuf 是 Protobuf Buffers 的简称，它是 Google 公司开发的一种数据描述语言，并于2008年开源。
可用作为设计安全的跨语言 RPC 接口的基础工具。
目前 Protobuf 已经发展到第3版本，即 syntax = "proto3"; 你将会学到
如何编写 protobuf 文件 如何通过protoc工具生成 go 代码 编写 protobuf 文件 先定义语法版本 再定义package 定义一个 service 定义一组 request，response 的 message 创建 hello.proto 文件
第一行结尾需要写上分号; service 相当于定义接口， rpc 定义未实现的接口方法 message 相当于定义一个结构体，里面定义字段属性， 先类型后变量名，然后序列号。 每一行数据类型后需要写一个编号，从1开始，因为编码是通过成员的唯一编号来绑定对应的数据。 推荐使用请求message后加上Request关键字, 如StringRequest 推荐使用响应message后加上Response关键字，如StringResponse // 选择 proto3 语法 syntax = "proto3"; // 定义一个包名为 hello package hello; // 定义一个 service 服务名为 HelloService，相当于 GO 接口定义 service HelloService { // 以 rpc 开头，定义未实现的方法名称。 必须要有一个请求 message 和响应 message // rpc, returns 都是关键字 rpc Hello(StringRequest) returns (StringResponse){}; } // message 相当于一个结构体，里面定义字段属性， 先类型后变量名，然后序列号。 // protoful 编码是通过成员的唯一编号来绑定对应的数据。 // 定义一个请求结构体 message StringRequest { string value = 1; } // 定义一个响应结构体 message StringResponse { string result = 1; } 标量类型 以下只列出常用的类型对应关系。更多参考最下面的链接<div class=read-more-link><a href=/posts/tutorial-grpc-protobuf/>Read More…</a></div></article><article class=post><div class=info><h1 class=post-title><a href=https://yezihack.github.io/posts/tutorial-grpc-base/>Go 实践教程-gRPC-简介(五)</a></h1><time datetime=2020-10-21T14:18:34+0800 class=post-date>October 21, 2020</time><ul class=tags><li class=tag-Go实践教程><a href=https://yezihack.github.io/tags/go%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B>Go实践教程</a></li><li class=tag-golang><a href=https://yezihack.github.io/tags/golang>golang</a></li><li class=tag-教程><a href=https://yezihack.github.io/tags/%E6%95%99%E7%A8%8B>教程</a></li><li class=tag-grpc入门><a href=https://yezihack.github.io/tags/grpc%E5%85%A5%E9%97%A8>grpc入门</a></li></ul></div>什么是gRPC RPC 是远程过程调用 (Remote Procedure Call)的缩写。在 RPC 中，客户端应用程序可以直接调用不同机器上的服务器应用程序上的方法，就像它是本地对象一样，使您可以更轻松地创建分布式应用程序和服务。
gRPC 是 Google 开源的基于 Protobuf 和 Http2.0 协议的通信框架，底层由netty提供。
是一款语言中立、平台中立、开源的远程过程调用(RPC)系统。
特点 基于HTTP/2协议实现，实现多路复用，双向流等特点。 基于 Protobuf 协议，支持多种语言。 参考 gRPC 官方文档中文版
推荐学习 gRPC入门 简介 gRPC入门 Protobuf gRPC入门 搭建完整gRPC gRPC入门 实现双向流</article></div><hr><div class=footer><nav id=page-nav><a href=/page/9/ rel=prev class="extend prev">&#171; Previous</a>
<a href=/>1</a>
<a href=/page/2/>2</a>
<a href=/page/3/>3</a>
<a href=/page/4/>4</a>
<a href=/page/5/>5</a>
<a href=/page/6/>6</a>
<a href=/page/7/>7</a>
<a href=/page/8/>8</a>
<a href=/page/9/>9</a>
<span class="page-number current">10</span>
<a href=/page/11/>11</a>
<a href=/page/12/>12</a>
<a href=/page/13/>13</a>
<a href=/page/14/>14</a>
<a href=/page/15/>15</a>
<a href=/page/16/>16</a>
<a href=/page/17/>17</a>
<a href=/page/18/>18</a>
<a href=/page/11/ rel=next class="extend next">Next &#187;</a></div></main></div></body></html>